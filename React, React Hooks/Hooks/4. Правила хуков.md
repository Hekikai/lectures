Хуки, как уже известно, это просто JavaScript-функции; для хуков существует два правила:
1. **Использовать хуки стоит лишь на верхнем уровне.** Не стоит вызывать хуки в циклах, условных операторов или вложенных функций. Вместо этого всегда используйте хуки только внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами `useState` и `useEffect`
2. **Вызывать хуки стоит только из React-функций.** Не надо вызывать хуки из обычных JavaScript-функий. Вместо этого можно:
- вызывать хуки из функционального компонента React;
- вызывать хуки из пользовательского хука ([[5. Создание пользовательских хуков]])

Следуя этим правилам, можно гарантировать, что вся логика состояния компонента будет чётка видна из исходного кода.


#Объяснение
Почему же правила хуков, которые описаны выше, необходимы?

Как мы уже знаем, хуки состояния или эффектов можно вызывать в одном и том же компоненте многократно.

Итак, как же React сопоставляет переменные состояния с вызовами `useState`? Ответ таков: **React полагается на порядок вызова хуков**. Как-будто читает код компоненты синхронно - строчка за строчкой. 

До тех пор пока порядок вызова хуков одинаков в каждом рендере, React может сопоставить некое внутреннее состояние с каждым из них. И если иметь какое-то условие внутри компоненты, то понятно, что порядок вызова хуков изменится. 

И React не будет знать, какую информацию использовать в следующем хуке, ведь раньше было по-другому!