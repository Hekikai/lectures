Обычно, функции пораждают только лишь одно значение.
Генераторы же могут пораждать множество значений - yeild - одно за другим, по мере необходимости. 
Некий конвейер, который выдаёт значение по требованию.

Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.

**Функция-генератор**

Для объявления генератора используется специальная синтаксическая конструкция: `function*`, которая называется «функция-генератор».

Выглядит она так:
```js
function* generateSequence() {
	yield 1;
	yield 2;
	return 3;
}
```
Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.

Основным методом генератора является `next()`. При вызове он запускает выполнение кода до ближайшей инструкции `yield <значение>` (значение может отсутствовать, в этом случае оно предполагается равным `undefined`). По достижении `yield` выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:

Результатом метода `next()` всегда является объект с двумя свойствами:

-   `value`: значение из `yield`.
-   `done`: `true`, если выполнение функции завершено, иначе `false`.

Например, здесь мы создаём генератор и получаем первое из возвращаемых им значений:
```js
function* generateSequence() {
	yield 1;
	yield 2;
	return 3;
}

let generator = generateSequence();

let one = generator.next();

console.log(JSON.stringify(one)); // {value: 1, done: false}
```

Три раза вызвав `next()`, мы получим объект, в котором значение `value` будет равно 3, а `done` - true.
Если дальше использовать метод `next()`, то никакой ошибки не будет - будет всегда просто возвращаться объект с `done`, равным true.

**Перебор генераторов**

Как вы, наверное, уже догадались по наличию метода `next()`, генераторы являются [перебираемыми](https://learn.javascript.ru/iterable) объектами.

Возвращаемые ими значения можно перебирать через `for..of`:
```js
function* generateSequence() {
	yield 1;
	yield 2;
	return 3;
}

let generator = generateSequence();

for(let value of generator) {
	console.log(value); //1, затем 2
}
```

3 не будет залогировано в консоль, связано с тем, что перебор через `for..of` игнорирует последнее значение, при котором `done: true`. Поэтому, если мы хотим, чтобы были все значения при переборе через `for..of`, то надо возвращать их через `yield`.

**Использование генераторов для перебираемых объектов**

Попробуем написать функционал, который дает `[Symbol.iterator]()`, но выглядеть он будет попроще:
```js
let range = {
	from: 1,
	to: 5,

	*[Symbol.iterator]() {
		for(let value = this.from; value <= this.to; value++) {
			yield value;
		}
	}
};

console.log( [...range] ); // 1,2,3,4,5
```
Это работает, потому что `range[Symbol.iterator]()` теперь возвращает генератор, и его методы – в точности то, что ожидает `for..of`:

-   у него есть метод `.next()`
-   который возвращает значения в виде `{value: ..., done: true/false}`

Это не совпадение, конечно. Генераторы были добавлены в язык JavaScript, в частности, с целью упростить создание перебираемых объектов.

Вариант с генератором намного короче, чем исходный вариант перебираемого `range`, и сохраняет те же функциональные возможности.

**мы можем итерироваться вечно по генератору**. А значит, нам нужен какой-нибудь `break` или же `return`. Иначе перебор в цикле `for...of` просто "сломает" скрипт.

**Композиция генераторов**

Мы можем "вкладывать" генераторы один в другой (осуществлять их композицию) с помощью синтаксиса `yield*`.

Пример генератора с композицией:
```js
function* generateSequence(start,end) {
	for (let i = start; i<= end; i++) yield i;
}

function* generatePasswordCodes() {
	//0...9
	yield* generateSequence(48, 57);

	// A...Z
	yield* generateSequence(65, 90);

	//a...z
	yield* generateSequence(97, 122);

}

let str = '';

for(let code of generatePasswordCodes()) {
	str += String.fromCharCode(code);
}

console.log(str);
```

Директива `yield*` делегирует выполнение другому генератору! Этот термин означает, что `yield* gen` перебирает генератор `gen` и прозрачно направляет его вывод наружу. Как если бы значения были сгенерированы внешним генератором.

Композиция генераторов – естественный способ вставлять вывод одного генератора в поток другого. *Она не использует дополнительную память для хранения промежуточных результатов.*

**yield - дорога в обе стороны**

yield, yield, перебираемые объекты - все это уже было. Но генераторы намного гибче и мощнее, чем все это вышеперечисленное.

Вся суть таится в том, что `yield` *не только возвращает результат наружу*, но и может *передавать значение извне в генератор*.

Чтобы это сделать, нам нужно вызвать `generator.next(arg)` с аргументом. Этот аргумент становится результатом `yield`.

Продемонстрируем это на примере:
```js
function* gen() {
	let result = yield* '2 + 2 = ?';

	console.log(result);
}

let generator = gen();

let question = generator.next().value; // <- возвращает значение

generator.next(4); // <- передаем извне в генератор
```

Как видно, в отличие от обычных функций, генератор может обмениваться результатами с вызывающим кодом, передавая значения в `next/yield`.

Если делать несколько `yield*` в генераторе, занося их в переменную, то можно играть в «пинг-понг»: каждый `next(value)` передаёт в генератор значение, которое становится результатом текущего `yield`, возобновляет выполнение и получает выражение из следующего `yield`. 

**generator.throw**

Можно передавать не только значения, но и ошибки! Ведь ошибка тоже является своего рода результатом...

Все, что нужно - вызвать `generator.throw(err)`:
```js
function* gen() {
	try {
		let result = yield* '2 + 2 = ?'; // (1)
	} catch (err) {
		console.log(err);
	}
}

let generator = gen();

let question = generator.next().value;

generator.throw(new Error("Ответ не найден в моей базе данных")); // (2)
```

Ошибка, которая проброшена в генератор на строке `(2)`, приводит к исключению на строке `(1)` с `yield`. В примере выше `try..catch` перехватывает её и отображает.

Если мы не хотим перехватывать её, то она, как и любое обычное исключение, «вывалится» из генератора во внешний код. Так что придется использовать `try...catch` уже снаружи, не внутри генератора.

