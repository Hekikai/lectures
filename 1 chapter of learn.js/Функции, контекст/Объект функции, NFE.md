В JS функции - это объекты. Так что их можно не только вызывать, но и использовать как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.

**Свойство name**

Объект функции содержит несколько полезных свойств. Например, имя функции можно получить, обратившись к свойству "name":
```js
function sayHi(){
	alert('Hi');
}

alert(sayHi.name); // sayHi
```
Что довольно забавно, логика назначения `name` весьма умная. Она присваивает корректное имя даже в случае, когда функция создаётся без имени и тут же присваивается (Function Expression).

Это работает даже в случае присваивания значения по умолчанию:
```js
function f(sayHi = function() {}) {
	alert(sayHi.name); // sayHi (работает!)
}

f();
```
В спецификации это называется **«контекстное имя»**: если функция не имеет name, то JavaScript пытается определить его из контекста.

Также имена имеют и методы объекта!

В этом нет никакой магии. Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение. Например:
```js
let arr = [function() {}];

alert(arr[0].name) // <пустая строка>
```
Впрочем, на практике такое бывает редко, обычно функции имеют `name`.

**Свойство length**
Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. Например:
```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
Как мы видим, троеточие, **обозначающее «остаточные параметры»**, здесь как бы «не считается». 

Свойство `length` иногда используется для [интроспекций](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D1%80%D0%BE%D1%81%D0%BF%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) в функциях, которые работают с другими функциями.

Например, в коде ниже функция `ask` принимает в качестве параметров вопрос `question` и произвольное количество функций-обработчиков ответа `handler`.

Когда пользователь отвечает на вопрос, функция вызывает обработчики. Мы можем передать два типа обработчиков:

-   Функцию без аргументов, которая будет вызываться только в случае положительного ответа.
-   Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.

Чтобы вызвать обработчик `handler` правильно, будем проверять свойство `handler.length`.

Идея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов (наиболее распространённый случай), но также и возможность передавать универсальные обработчики:
```js
function ask(question, ...handlers) {
	let isYes = confirm(question);
	
	for(let handler of handlers) {
		if (handler.length == 0) {
			if (isYes) handler();
		} else {
			handler(isYes);
		}
	}
}

// для положительных ответов вызываются оба типа обработчиков
// для отрицательных - только второго типа

ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));
```

**Пользовательские свойства**
Мы также можем добавить свои собственные свойства.

Давайте добавим свойство `counter` для отслеживания общего количества вызовов:
```js
function sayHi() {
	alert("Hi");
	
	// давайте посчитаем, сколько вызовов мы сделали
	sayHi.counter++;
}

sayHi.counter = 0; // начальное значение
sayHi(); // Hi
sayHi(); // Hi

alert(sayHi.counter) ; // 2
```

**СВОЙСТВО НЕ ЕСТЬ ПЕРЕМЕННАЯ**

Свойство функции, назначенное как `sayHi.counter = 0`, **не объявляет локальную переменную** `counter` внутри неё. Другими словами, свойство `counter` и переменная `let counter` – это две независимые вещи. (Локальные переменные хранятся в [Environment Record](Замыкание#^af686d)

Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот. Это два параллельных мира.

**Named Function Expression**
Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.

Например, давайте объявим Function Expression:
```js
let sayHi = function(who) {
	alert(`Hello, ${who}`);
};
```
И присвоим ему имя:
```js
let sayHi = function func(who) {
	alert(`Hello, ${who}`);
};
```
Чего мы здесь достигли? Какова цель этого дополнительного имени `func`?

Для начала заметим, что функция всё ещё задана как Function Expression. Добавление `"func"` после `function` не превращает объявление в Function Declaration, потому что оно все ещё является частью выражения присваивания.

Добавление такого имени ничего не ломает.

Функция все ещё доступна как `sayHi()`:
```js
let sayHi = function func(who) {
	alert(`Hello, ${who}`);
};

sayHi('John'); // Hello, John
```
Есть две важные особенности имени `func`, ради которого оно даётся:

1.  Оно позволяет функции ссылаться на себя же.
2.  Оно не доступно за пределами функции.

Например, ниже функция `sayHi` вызывает себя с `"Guest"`, если не передан параметр `who`:
```js
let sayHi = function func(who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		func('Guest'); // Вызывает себя же, но с другим параметром
	}
};

sayHi(); // Hello, Guest

// А вот так - не сработает:
func(); // Ошибка, func недоступна вне функции
```
Почему бы нам не вызывать `sayHi()` в той строчке, где вызывается `func('Guest')`? Есть проблема - значение `sayHi` может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнёт выдавать ошибки:
```js
let sayHi = function (who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		sayHi('Guest'); // Ошибка: sayHi не является функцией
	}
};

let welcome = sayHi;
sayHi = null;

welcome(); // Ошибка, вложенный вызов sayHi больше
		   // не сработает!
```
Так происходит, потому что функция берёт `sayHi` из внешнего лексического окружения. Так как локальная переменная `sayHi` отсутствует, используется внешняя. И на момент вызова эта внешняя `sayHi` равна `null`.

Необязательное имя, которое можно вставить в Function Expression, как раз и призвано решать такого рода проблемы.

Давайте используем его, чтобы исправить наш код:
```js
let sayHi = function func(who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		func('Guest'); // Теперь все окей!
	}
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вложенный вызов)
```

Теперь всё работает, потому что имя `"func"` локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.

Внешний код все ещё содержит переменные `sayHi` и `welcome`, но теперь `func` – это «внутреннее имя функции», таким образом она может вызвать себя изнутри.

**Стоит понимать, что это не работает с Function Declaration**.
Трюк с «внутренним» именем, описанный выше, работает только для Function Expression и **не работает для Function Declaration**. Для Function Declaration **синтаксис не предусматривает возможность** объявить дополнительное «внутреннее» имя.
Зачастую, когда нам нужно надёжное «внутреннее» имя, стоит переписать Function Declaration на Named Function Expression.