При передаче методов объекта в качестве колбэков, например для `setTimeout`, возникает известная проблема – потеря `this`. 

Посмотрим, как можно избавиться от этой проблемы.

**Потеря this**

Мы уже видели примеры потери `this`. Как только метод передаётся отдельно от объекта – `this` теряется.

Вот как это может произойти в случае с `setTimeout`:

```js
let user = {
	firstName: "Вася",
	sayHi() {
		alert(`Привет, ${this.firstName}!`);
	}
};

setTimeout(user.sayHi, 1000); // Привет, undefined!
```
При запуске этого кода мы видим, что вызов `this.firstName` возвращает не «Вася», а `undefined`!

Это произошло потому, что `setTimeout` получил функцию `sayHi` отдельно от объекта `user` (именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:
```js
let f = user.sayHi;
setTimeout(f, 1000); // Контекст user потеряли
```
Метод `setTimeout` в браузере имеет особенность: он устанавливает `this=window` для вызова функции (в Node.js `this` становится объектом таймера, но здесь это не имеет значения). Таким образом, для `this.firstName` он пытается получить `window.firstName`, которого не существует. В других подобных случаях `this` обычно просто становится `undefined`.

Задача довольно типичная – мы хотим передать метод объекта куда-то ещё (в этом конкретном случае – в планировщик), где он будет вызван. Как бы сделать так, чтобы он вызывался в правильном контексте?

**Решение 1: сделать функцию-обёртку**

Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:
```js
let user = {
	firstName: "Вася",
	sayHi() {
		alert(`Привет, ${this.firstName}!`);
	}
};

setTimeout(function() {
	user.sayHi(); // Привет, Вася!
}, 1000);
```
Теперь код работает корректно, так как объект `user` достаётся из замыкания, а затем вызывается его метод `sayHi`.
Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

Что произойдёт, если до момента срабатывания `setTimeout` (ведь задержка составляет целую секунду!) в переменную `user` будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!
```js
let user = {
	firstName: "Вася",
	sayHi() {
		alert(`Привет, ${this.firstName}!`);
	}
};

setTimeout(() => user.sayHi(), 1000);

// ... в течение 1 секунды
user = { sayHi() { alert('Другой пользователь в 'setTimeout!'); } };

// Другой пользователь в 'setTimeout'!
```
Следующее решение гарантирует, что такого не случится.

**Решение 2: привязать контекст с помощью bind**

В современном JavaScript у функций есть встроенный метод [bind](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind), который позволяет зафиксировать `this`.

Базовый синтаксис `bind`:
```js
let boundFunc = func.bind(context);
```

Результатом вызова `func.bind(context)` является особый «экзотический объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в `func`, при этом устанавливая `this = context`.

Другими словами, вызов `boundFunc` подобен вызову `func` с фиксированным `this`.

Например, здесь `funcUser` передаёт вызов в `func`, фиксируя `this = user`:

```js
let user = {
	firstName: 'Вася',
};

function func(){
	alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // Вася
```
Здесь `func.bind(user)` – это «связанный вариант» `func`, с фиксированным `this=user`.

Все аргументы передаются исходному методу `func` как есть, например:
```js
let user = {
	firstName: 'Вася',
};

function func(phrase){
	alert(phrase + ', ' + this.firstName);
}

let funcUser = func.bind(user);

funcUser('Привет'); // Привет, Вася
```

Это же можно применить к методу объекта:
```js
let user = {
	firstName: 'Вася',
	sayHi() {
		alert(`Привет, ${this.firstName}!`);
	}
};

let sayHi = user.sayHi.bind(user); // (*)

sayHi(); // Привет, Вася!

setTimeout(sayHi, 1000); // Привет, Вася!
```
В строке `(*)` мы берём метод `user.sayHi` и привязываем его к `user`. Теперь `sayHi` – это «связанная» функция, которая может быть вызвана отдельно или передана в `setTimeout` (контекст всегда будет правильным).

Здесь мы можем увидеть, что `bind` исправляет только `this`, а аргументы передаются как есть:
```js
let user = {
	firstName: 'Вася',
	sayHi() {
		alert(`Привет, ${this.firstName}!`);
	}
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
```

Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для ниъ всех в цикле:
```js
for(let key in user){
	if(typeof user[key] == 'function'){
		user[key] = user[key].bind(user);
	}
}
```

**Частичное применение**
До сих пор мы говорили только о привязывании `this`. Давайте шагнём дальше.

Мы можем привязать не только `this`, но и аргументы. Это делается редко, но иногда может быть полезно.

Полный синтаксис `bind`:
```js
let bound = func.bind(context, [arg1], [arg2], ...);
```
Это позволяет привязать контекст `this` и начальные аргументы функции.

Например, у нас есть функция умножения `mul(a, b)`:
```js
function mul(a,b) {
	return a * b;
}
```
Давайте воспользуемся `bind`, чтобы создать функцию `double` на её основе:
```js
function mul(a,b) {
	return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```
Вызов `mul.bind(null, 2)` создаёт новую функцию `double`, которая передаёт вызов `mul`, фиксируя `null` как контекст, и `2` – как первый аргумент. Следующие аргументы передаются как есть.

Это называется [частичное применение](https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5) – мы создаём новую функцию, фиксируя некоторые из существующих параметров.

Обратите внимание, что в данном случае мы на самом деле не используем `this`. Но для `bind` это обязательный параметр, так что мы должны передать туда что-нибудь вроде `null`.

Для чего мы обычно создаём частично применённую функцию?

Польза от этого в том, что возможно создать независимую функцию с понятным названием (`double`, `triple`). Мы можем использовать её и не передавать каждый раз первый аргумент, т.к. он зафиксирован с помощью `bind`.

В других случаях частичное применение полезно, когда у нас есть очень общая функция и для удобства мы хотим создать её более специализированный вариант.

Например, у нас есть функция `send(from, to, text)`. Потом внутри объекта `user` мы можем захотеть использовать её частный вариант: `sendTo(to, text)`, который отправляет текст от имени текущего пользователя.

**Частичное применение без контекста**
Что если мы хотим зафиксировать некоторые аргументы, но не контекст `this`? Например, для метода объекта.

Встроенный `bind` не позволяет этого. Мы не можем просто опустить контекст и перейти к аргументам.

К счастью, легко создать вспомогательную функцию `partial`, которая привязывает только аргументы.

Вот так:
```js
function partial(func, ...argsBound) {
	return function(...args) { // (*)
		return func.call(this, ...argsBound, ...args);
	}
}

// Использование:

let user = {
	firstName: "John",
	say(time, phrase) {
		alert(`[${time}] ${this.firstName}: ${phrase}!`);
	}
};

// Добавляем частично применённый метод с фиксированным временем

user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

user.sayNow("Hello");
// Что-то вроде этого:
// [10:00] John: Hello!
```
Результатом вызова `partial(func[, arg1, arg2...])` будет обёртка `(*)`, которая вызывает `func` с:

-   Тем же `this`, который она получает (для вызова `user.sayNow` – это будет `user`)
-   Затем передаёт ей `...argsBound` – аргументы из вызова `partial` (`"10:00"`)
-   Затем передаёт ей `...args` – аргументы, полученные обёрткой (`"Hello"`)

Благодаря оператору расширения `...` реализовать это очень легко, не правда ли?