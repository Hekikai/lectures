**1.1 Преобразование типов**

Когда интерпретатор JavaScript **ожидает булевское значение**, вы можете предоставить значение любого типа, и интерпретатор JavaScript при необходимости преобразует его. Одни значения ("истинные" значения) преобразуются в true, а другие ("ложные" значения) - в false. 
То же самое справедливо для остальных типов: если интерпретатор JavaScript пожелает **иметь строку**, тогда любое переданное вами значение будет **преобразовано в строку**. Если интерпретатор JavaScript **желает число**, то **попробует преобразовать **предоставленное вами **значение в число** (или в NaN, когда осмысленное преобразование невозможно).

Значение | Преобразование в строку|Преобразование в число | Преобразование в булевское значение
------ | ------------ | ---------- | ---------
undefined | "undefined" | NaN | false 
null | "null" | 0 | false 
true | "true" | 1 |  
false | "false" | 0 |  
"" (пустая строчка)|  | 0 | false 
"1.2" |  | 1.2 | true  
"one" |  | NaN | true  
0    | "0" |  | false
-0 | "0" |  | false 
1 | "1" |  | true
Infinity | "Infinity" |  | true
-Infinity | "-Infinity" |  | true
NaN | "NaN" |  | false
{} | Описано ниже | Описано ниже | true
[] | "" | 0 | true
[9] |"9"  | 9 | true 
["a"]  | join() | NaN | true
function(){}  | Описано ниже | NaN | true 

Строки, которые могут быть разобраны как числа, преобразуются в эти числа. Начальные и конечные пробелы разрешены, но наличие любых начальных или конечных непробельных символов, не являющихся частью числового литерала, приведет к тому, что результатом преобразования строки в число окажется NaN.

**1.2 Преобразования и равенство**

В JavaScript есть две операции, которые проверяют, равны ли два значения. “Операция строгого равенства” не считает свои операнды равными, если они не относятся к одному и тому же типу, и при написании кода она почти всегда будет правильным выбором. Но поскольку язык JavaScript настолько гибок в плане преобразований типов, в нем определена также и операция == с гибкой формулировкой равенства. Все нижеследующие сравнения дают true:
```js
null == undefined
"0" == 0
0 == false
"0" == false
```
Имейте в виду, что возможность преобразования одного значения в другое вовсе не подразумевает равенство этих двух значений. Например, если undefined используется там, где ожидается булевское значение, то оно будет преобразовано в false . Но это не означает, что undefined == false . Операции и операторы JavaScript ожидают значения разнообразных типов и выполняют преобразования в них. Оператор `if` преобразует undefined в false , но **операция == никогда не пытается преобразовывать свои операнды в булевские значения**.

**1.3 Явные преобразования**

Хотя JavaScript выполняет многие преобразования типов автоматически, иногда вам может понадобиться явное преобразование или, возможно, вы предпочитаете делать преобразования явно, поддерживая ясность своего кода.

Простейший способ выполнения явных преобразований типов предусматривает применение функций Boolean (), Number () и String():
```js
Number("3")   // => 3
String(false) // => "false"
Boolean([])   // => true
```

**Любое значение кроме null и undefined** имеет метод toString(), результат которого обычно будет таким же, как возвращаемый функцией String().

Определенные операции JavaScript выполняют неявное преобразование типов и временами используются явно в целях преобразования типов. Если одним операндом операции + является строка, тогда другой операнд преобразуется в строку. Унарная операция + преобразует свой операнд в число. Унарная операция ! преобразует свой операнд в булевское значение и инвертирует его. Перечисленные факты приводят к следующим идиомам преобразования типов, которые вы могли встречать в коде:
```js
x + "" // => String(x)
+x     // => Number(x)
x - 0  // => Number(x)
!!x    // Boolean(x): обратите внимание на два символа !
```
Метод `toString ()`, определенный в классе Number, принимает необязательный аргумент, где задается основание системы счисления для преобразования. Если вы не укажете этот аргумент, то преобразование будет делаться по основанию 10. Однако вы можете также преобразовывать числа в другие системы счисления.
```js
let n = 17;

let hex = "0x" + n.toString(16); // hex == "0x11"
```

**Методы: `toFixed()`, `toExponential()` и `toPrecision()` возращают всегда строку!**

Функции `parselnt ()` и `parseFloat ()` (это глобальные функции, не методы какого-то класса) более гибкие, `parselnt ()` разбирает только целые числа, в то время `parseFloat ()` — целые числа и числа с плавающей точкой. Если строка начинается с 0х или 0Х, то `parselnt()` интерпретирует ее как шестнадцатеричное число. Оба метода, `parselnt()` и `parseFloat()`, пропускают начальные пробельные символы, разбирают столько числовых символов, сколько могут, и игнорируют все, что находится за ними. Если первый непробельный символ не является частью допустимого числового литерала, тогда они возвращают NaN.

Функция `parselnt ()` принимает необязательный второй аргумент, указывающий основание системы счисления числа, которое подлежит разбору. Допустимые значения находятся между 2 и 36.

**1.3 Преобразование объектов в элементарные значения**

Одна из причин сложности преобразований объектов в элементарные значения связана с тем, что некоторые типы объектов имеют несколько элементарных представлений. Скажем, объекты дат могут быть представлены как строки или как числовые отметки времени. **В спецификации JavaScript** определены три фундаментальных алгоритма для преобразования объектов в элементарные значения:

- **prefer-string**
Этот алгоритм возвращает элементарное значение, отдавая предпочтение строке, если такое преобразование возможно.

- **prefer-number**
Этот алгоритм возвращает элементарное значение, отдавая предпочтение числу, если такое преобразование возможно.

- **no-preference**
Этот алгоритм не отдает никаких предпочтений относительно того, какой тип элементарного значения желателен, и классы могут определять собственные преобразования. Все встроенные типы JavaScript, исключая Date, реализуют данный алгоритм как prefer-number. Класс Date реализует его как prefer-string.

Реализация перечисленных алгоритмов преобразования объектов в элементарные значения объясняется в конце раздела. Но сначала нужно выяснить, как такие алгоритмы используются в JavaScript.

**Преобразование объектов в булевские значения**

Преобразование объектов в булевские значения тривиальные: все объекты преобразуются в true. Данное преобразование не требует описанных выше алгоритмов. 

**Преобразование объектов в строковые значения**

Когда объект нужно преобразовать в строку, интерпретатор JavaScript сначала преобразует его в элементарное значение, используя алгоритм `prefer-string`, а затем при необходимости преобразует результирующее элементарное значение в строку, следуя правилам из таблицы выше.

**Преобразование объектов в числовые значения**

Когда объект нужно преобразовать в число, интерпретатор JavaScript сначала преобразует его в элементарное значение, используя алгоритм `prefer-number`, а затем при необходимости преобразует результирующее элементарное значение в число, следуя правилам из таблицы выше.

**Методы toString() и valueOf()**

Все объекты наследуют два метода преобразования, которые применяются преобразованиями объектов в элементарные значения, и прежде чем можно будет объяснять алгоритмы преобразования `prefer-string`, `prefer-number` и `no-preference`, нужно взглянуть на эти два метода.

Первым методом является `toString()`, задача которого — возвратить строковое представление объекта. Стандартный метод `toString()` возвращает не особо интересное значение.

Другая функция преобразования объектов называется `valueOf()`. Задача этого метода определена менее четко: предполагается, что **он должен преобразовывать объект в элементарное значение**, которое представляет объект, если такое элементарное значение существует. Объекты являются составными значениями, причем большинство объектов на самом деле не могут быть представлены единственным элементарным значением, а потому стандартный метод `valueOf()` возвращает сам объект вместо элементарного значения.

**Алгоритмы преобразований объектов в элементарные значения**

После обсуждения методов `toString()` и `valueOf()` теперь мы можем схематично объяснить, как работают три алгоритма преобразования объектов в элементарные значения:

- Алгоритм `prefer-string` сначала испытывает метод `toString()`. Если он определен и возвращает элементарное значение, тогда интерпретатор JS использует это элементарное значение (даже когда оно отлично от строки!). Если `toString()` не существует или возвращает объект, то интерпретатор JavaScript испытывает метод `valueOf()`. Если он определен и возвращает элементарное значение, тогда интерпретатор JavaScript использует это значение. Иначе преобразование терпит неудачу с выдачей ошибки типа (ТуреЕггог).
- Алгоритм `prefer-number` работает аналогично алгоритму `prefer-string`, но первым испытывается `valueOf()`, а вторым — `toString()`.
- Алгоритм `no-preference` зависит от класса преобразуемого объекта. Если объект относится к классу `Date`, тогда интерпретатор JavaScript применяет алгоритм `prefer-string`. Для любого другого объекта интерпретатор JavaScript использует алгоритм `prefer-number`.

В завершение данной темы полезно отметить, что детали преобразования `prefer-number` объясняют, почему пустые массивы преобразуются в число 0 и одноэлементные массивы также могут быть преобразованы в числа:
```js
Number([])    // => 0
Number([727]) // => 727
```
Преобразование объектов в числа сначала преобразует объект в элементарное значение с применением алгоритма `prefer-number`, после чего преобразует результирующее элементарное значение в число. Алгоритм `prefer-number` первым испытывает `valueOf()` и затем возвращается к `toString()`. Но класс `Array` наследует стандартный метод `valueOf()`, который не возвращает элементарное значение. Таким образом, когда мы пытаемся преобразовать массив в число, то в итоге получаем вызов метода `toString()` массива. Пустой массив преобразуется в пустую строку, а пустая строка преобразуется в число 0. Массив с единственным элементом преобразуется в ту же строку, что и этот один элемент. Если массив содержит единственное число, то оно преобразуется в строку и затем обратно в число.