В ООП класс - это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

На практике приходится создавать много объектов одного вида, например пользователей, товары или что-то ещё.
Это можно делать с помощью `new function`.

Но в современном JavaScript есть и более продвинутая конструкция "class", которая предоставляет новые возможности, полезные для ООП.

**Синтаксис "class"**

Базовый класс выглядит так:
```js
class MyClass {
	// методы класса
	constructor(){...}
	method1(){...}
	method2(){...}
	...
}
```
Затем используйте вызов `new MyClass()` для создания нового инстанса со всеми перечисленными методами.

При этом вызывается автоматически метод `constructor()`, в нём мы можем инициализировать объект.
Например:
```js
class User {

	constructor(name) {
		this.name = name;
	}

	sayHi() {
		console.log(this.name);
	}

}

// Использование:
let user = new User("Иван")
user.sayHi();
```
Когда вызывается `new User("Иван")`:

1.  Создаётся новый объект.
2.  `constructor` запускается с заданным аргументом и сохраняет его в `this.name`.

…Затем можно вызывать на объекте методы, такие как `user.sayHi()`.
****
**Методы в классе не разделяются запятой**

Частая ошибка начинающих разработчиков – ставить запятую между методами класса, что приводит к синтаксической ошибке.

Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.
****
**Что такое класс?**

Итак, что же такое `class`? Это не полностью новая языковая сущность, как может показаться на первый взгляд.

В JavaScript класс - это разновидность функции.

Взгляните:
```js
class User {
	constructor(name) { this.name = name; }
	sayHi() { console.log(this.name); }
}

// User - это функция
console.log(typeof User); // function
```

Вот что на самом деле делает конструкция `class User {...}`:

1.  Создаёт функцию с именем `User`, которая становится результатом объявления класса. Код функции берётся из метода `constructor` (она будет пустой, если такого метода нет).
2.  Сохраняет все методы, такие как `sayHi`, в `User.prototype`.

При вызове метода объекта `new User` он будет взят из прототипа, как описано в [[F.prototype]]. Таким образом, объекты `new User` имеют доступ к методам класса.

Можно проверить все вышесказанное и при помощи кода:
```js
class User {
	constructor(name) { this.name = name; }
	sayHi() { console.log(this.name); }
}
// Класс - это функция
console.log(typeof User); // function
// ...или, если точнее, это метод constructor
console.log(User === User.prototype.constructor); // true
// Методы находятся в User.prototype, например:
console.log(User.prototype.sayHi); //console.log(this.name)
// И в прототипе ровно 2 метода
console.log(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

**Не просто синтаксический сахар**
Иногда говорят, что `class` – это просто «синтаксический сахар» в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому что мы можем сделать всё то же самое без конструкции `class`:
```js
// перепишем класс User на чистых функциях

// 1. Создаём функцию constructor
function User(name) {
	this.name = name;
}
// Каждый прототип функции имеет свойство constructor по умолчанию,
// поэтому нам нет необходимости его создавать.

// 2. Добавляем метод в прототип
User.prototype.sayHi = function() {
	console.log(this.name);
};

// Используем:
let user = new User("Иван");
user.sayHi();
```
Результат этого кода очень похож. Поэтому, действительно, есть причины, по которым `class` можно считать синтаксическим сахаром для определения конструктора вместе с методами прототипа.

Однако есть важные отличия:
1. Во-первых, функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[IsClassConstructor]]: true`. Поэтому это не совсем то же самое, что создавать её вручную.
В отличие от обычных функций, конструктор класса не может быть вызван без `new`.
Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг `enumerable` в`false` для всех методов в `"prototype"`.
    И это хорошо, так как если мы проходимся циклом `for..in` по объекту, то обычно мы не хотим при этом получать методы класса.
3. Классы всегда используют `use strict`. Весь код внутри класса автоматически находится в строгом режиме.
    
Также в дополнение к основной, описанной выше, функциональности, синтаксис `class` даёт ряд других интересных возможностей, с которыми мы познакомимся чуть позже.

**Class Expression**
Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.

Пример Class Expression (по аналогии с Function Expression):
```js
let User = class {
	sayHi(){
		console.log("Hello!");
	}
};
```
Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:
```js
// "Named Class Expression"
// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
let User = class MyClass {
	sayHi(){
		console.log("Hello!");
	}
};

new User().sayHi(); // Работает, выводит определение MyClass

console.log(MyClass); // Ошибка, имя MyClass не видно за пределами класса
```
Мы даже можем динамически создавать классы «по запросу»:
```js
function makeClass(phrase) {
	// объявляем класс и возвращаем его
	return class {
		sayHi(){
			console.log(phrase);
		};
	};
}

// Создаём новый класс
let User = makeClass("Привет");

new User().sayHi(); // Привет
```

**Геттеры/сеттеры, другие сокращения**

Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Вот пример `user.name`, реализованного с использованием `get/set`:
```js
class User {

	constructor(name) {
		this.name = name;
	}

	get name(){
		return this._name;
	}

	set name(value) {
		if(value.length < 4){
			console.log('Имя слишком короткое');
			return;
		}
		this._name = value;
	}
}

let user = new User("Иван");
console.log(user.name); // Иван

user = new User(""); // Имя слишком короткое.
```
При объявлении класса геттеры/сеттеры создаются на `User.prototype`, вот так:
```js
Object.defineProperties(User.prototype, {

	name: {
		get() {
			return this._name;
		},
		set (name) {
		//...
		}
	}	
});
```

**Свойства классов**
В приведённом выше примере у класса `User` были только методы. Давайте добавим свойство:
```js
class User {
	name = "Аноним";

	sayHi() {
		console.log(`Привет, ${this.name}!`);
	}
}

new User().sayHi();
```
Свойство `name` не устанавливается в `User.prototype`. Вместо этого оно создаётся оператором `new` перед запуском конструктора, это именно свойство объекта.
