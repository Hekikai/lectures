Один из важнейших принципов объектно-ориентированного программирования – разделение внутреннего и внешнего интерфейсов.

Это обязательная практика в разработке чего-либо сложнее, чем «hello world».

**Пример из реальной жизни**

Например, кофеварка. Простая снаружи: кнопка, экран, несколько отверстий… И, конечно, результат – прекрасный кофе! :) Но внутри - множество деталей. Но мы можем пользоваться ею, ничего об этом не зная.
Кофеварки довольно надёжны, не так ли? Мы можем пользоваться ими годами, и если что-то пойдёт не так – отнесём в ремонт.

Секрет надёжности и простоты кофеварки – все детали хорошо отлажены и _спрятаны_ внутри.

Если мы снимем защитный кожух с кофеварки, то пользоваться ею будет гораздо сложнее (куда нажимать?) и опаснее (может привести к поражению электрическим током).

Как мы увидим, в программировании объекты похожи на кофеварки.

Но, чтобы скрыть внутренние детали, мы будем использовать не защитный кожух, а специальный синтаксис языка и соглашения.

**Внутренний и внешний интерфейсы**

В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

-   _Внутренний интерфейс_ – методы и свойства, доступные из других методов класса, но не снаружи класса.
-   _Внешний интерфейс_ – методы и свойства, доступные снаружи класса.

Если мы продолжаем аналогию с кофеваркой – то, что скрыто внутри: трубка кипятильника, нагревательный элемент и т.д. – это внутренний интерфейс.

Внутренний интерфейс используется для работы объекта, его детали используют друг друга. Например, трубка кипятильника прикреплена к нагревательному элементу.

Но снаружи кофеварка закрыта защитным кожухом, так что никто не может добраться до сложных частей. Детали скрыты и недоступны. Мы можем использовать их функции через внешний интерфейс.

Итак, всё, что нам нужно для использования объекта, это знать его внешний интерфейс. Мы можем совершенно не знать, как это работает внутри, и это здорово.

Это было общее введение.

В JavaScript есть два типа полей (свойств и методов) объекта:

-   *Публичные*: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
-   *Приватные*: доступны только внутри класса. Они для внутреннего интерфейса.

Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или для дочерних классов (то есть, как приватные, но разрешён доступ для наследующих классов) и также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.

Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.

А теперь давайте сделаем кофеварку на JavaScript со всеми этими типами свойств. Кофеварка имеет множество деталей, мы не будем их моделировать для простоты примера (хотя могли бы).

**Защищенное свойство "waterAmount"**

Давайте для начала создадим простой класс для описания кофеварки:
```js
class CoffeeMachine {
	waterAmount = 0;

	constructor(power) {
		this.power = power;
		console.log( `Создана кофеварка, мощность: ${power}` );
	}
}

let cofeeMachine = new CoffeeMachine(100);

// Добавим воды
coffeeMachine.waterAmount = 200;
```
Прямо сейчас свойства `waterAmount` и `power` публичные. Мы можем легко получать и устанавливать им любое значение извне.

Давайте изменим свойство `waterAmount` на защищённое, чтобы иметь больше контроля над ним. Например, мы не хотим, чтобы кто-либо устанавливал его ниже нуля.

**Защищённые свойства обычно начинаются с префикса `_`.**

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.
Так что наше свойство будет называться `_waterAmount`:

```js
class CofeeMachine {
	_waterAmount = 0;

	set waterAmount(value) {
		if(value < 0) throw new Error('Отрицательное количество воды');
		this._waterAmount = value;
	}

	get waterAmount() { 
		return this._waterAmount;
	}

	constructor(power) { 
		this._power = power; 
	}
}

let coffeeMachine = new CoffeeMachine(100);

// Устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное
                                 // количество воды
```

Теперь доступ под контролем, поэтому указать воду ниже нуля не удалось.

**Cвойство только для чтения**

Давайте сделаем свойство `power` доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось.

Это как раз требуется для кофеварки: мощность никогда не меняется.

Для этого нам нужно создать только геттер, но не сеттер:
```js
class CoffeeMachine { 
	// ... 
	constructor(power) { 
		this._power = power; 
	} 

	get power() {
		return this._power;
	} 
} 
// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

console.log(`Мощность: ${coffeeMachine.power}W`);

coffeeMachine.power = 25; // Error (no setter)
```

****
**Геттеры/сеттеры**
Здесь мы использовали синтаксис геттеров/сеттеров.

Но в большинстве случаев использование функций `get.../set...` предпочтительнее:
```js
	setWaterAmount(value) { 
		if (value < 0) throw new Error("Отрицательное количество воды");
		this._waterAmount = value; 
	}

	getWaterAmount() { 
		return this._waterAmount;
	}
```

Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны). Итак, на будущее, если нам надо что-то отрефакторить, функции – более безопасный выбор.

С другой стороны, синтаксис get/set короче, решать вам.
****
**Наследование защищенных полей**

Если мы унаследуем `class MegaMachine extends CoffeeMachine`, ничто не помешает нам обращаться к `this._waterAmount` или `this._power` из методов нового класса.

Таким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.

**Приватное свойство "#waterLimit"**

Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов.

Приватные свойства и методы должны начинаться с `#`. Они доступны только внутри класса.

Например, в классе ниже есть приватное свойство `#waterLimit` и приватный метод `#checkWater` для проверки количества воды:
```js
class CoffeeMachine { 
	#waterLimit = 200; 

	#checkWater(value) { 
		if (value < 0) throw new Error("Отрицательный уровень воды");
		if (value > this.#waterLimit) throw new Error("Слишком много воды"); 
	}
}

let coffeeMachine = new CoffeeMachine(); 
// снаружи нет доступа к приватным методам класса 

coffeeMachine.#checkWater(); // Error 
coffeeMachine.#waterLimit = 1000; // Error
```

На уровне языка `#` является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.

Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно – приватное `#waterAmount` и публичное `waterAmount`.

Например, давайте сделаем аксессор `waterAmount` для `#waterAmount`:
```js
class CofeeMachine {

	#waterAmount = 0;

	get waterAmount() {
		return this.#waterAmount;
	}

	set waterAmount(value) { 
		if (value < 0) throw new Error("Отрицательный уровень воды"); 
		this.#waterAmount = value; 
	}
}

let machine = new CofeeMachine();

machine.waterAmount = 100;
console.log(machine.#waterAmount); // Error
```

В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

Но если мы унаследуем от `CoffeeMachine`, то мы не получим прямого доступа к `#waterAmount`. Мы будем вынуждены полагаться на геттер/сеттер `waterAmount`:
```js
class MegaCoffeeMachine extends CoffeeMachine {
	method() {
		console.log(this.#waterAmount); // Error: can only 
                                        // access from 
                                        // CoffeeMachine
	}
}
```

Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем `CoffeeMachine`, у нас может быть вполне законная причина для доступа к внутренним методам и свойствам. Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.