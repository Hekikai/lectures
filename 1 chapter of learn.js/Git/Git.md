Выжимка из книги ProGit, с которой можно ознакомиться и также скачать на русском языке, перейдя по этой ссылке: [ProGit](https://git-scm.com/book/ru/v2).
[[Содержание]]

**Введение**
***Система контроля версий*** - это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определенной версии. Она позволяет вернуть файлы к состоянию, в котором они были до изменений, вернуть проект к исходному состоянию, увидеть изменения, увидеть, кто последний менял что-то и вызвал проблему, кто поставил задачу и когда и многое другое.

Люди взаимодействуют друг с другом, поэтому есть необходимость в сравнении версий программы или же наблюдении за процессом разработки разных программистов:
![[Pasted image 20211206161752.png]]

И тут вступает в бой Git. Если сервер, на котором хранятся все данные, вдруг стал недоступен или если он просто "умер", то можно скопировать любой клиентский репозиторий на другой сервер для продолжения работы. **Каждая копия репозитория является полным бэкапом всех данных.**
![[Pasted image 20211206124358.png]]

**Что такое Git?**
Системы, отличные от Git, представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени.
![[Pasted image 20211206125005.png]]

В Git'e каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот сником. Git представляет свои данные как, скажем, **поток снимков**.
![[Pasted image 20211206125232.png]]

**Почти все операции выполняются локально**, именно поэтому системе не нужна никакая информация с других компьютеров в вашей сети. **Вся история проекта хранится прямо на вашем локальном диске**, большинтсов операций кажутся чуть ли не мгновенными.
Так что оффлайн работа с проектом, например, в самолете возможна, потому что все хранится у вас перед носом. Нужно лишь потом все синхронизировать, подключившись к Интернету.

# *** Целостность Git***

В Git для всего вычисляется хеш-сумма, а значит невозможно изменить содержимое файла или каталога так, чтобы Git про это не узнал. Git **сохраняет все объекты** в свою базу данных не по имени, а **по хеш-сумме** содержимого объекта.

***Три состояния***
У Git есть три основных состояния, в которых могут находиться ваши файлы: *изменен (modified)*, *индексирован (staged)* и *зафиксирован (commited)*:
- К изменёнными относятся файлы, которые поменялись, но ещё не были зафиксированы.
- Индексированный - это измененный файл в его текущей версии, отмеченный для включения в следующий коммит.
- Зафиксированный значит, что файл уже сохранён в вашей локальной базе.

Есть три основые секции проекта Git: *рабочая копия (working tree)*, *область индексирования (staging area)* и *каталог Git (Git directory)*.
![[Pasted image 20211206130449.png]]

Базовый подход при работе с Git выгляди так:
1. Изменяете файлы в вашей рабочей копии.
2. Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только *этих* изменений в индекс.
3. Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.

Если определённая версия файла есть в каталоге Git, эта версия считается *зафиксированной (committed)*. Если файл был изменён и добавлен в индекс, значит, он *индексирован (staged)*. И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается *изменённым (modified)*.

**Глава 1 - Основы Git**

# *Создание Git-репозитория*
Обычно вы получаете репозиторий Git одним из двух способов:
1. Взять локальный каталог, который не находится под версионным контролем, и преправить его в репозиторий Git
2. Клонировать существующий репозиторий Git из любого места.

***Создание Git-репозитория в существующем каталоге***

Находим директорию:
`$cd C:/Users/user/my_project`
а затем выполняем команду:
`$git init`
Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект **ещё не находится под версионным контролем.**
Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду `git add` несколько раз, указав индексируемые файлы, а затем выполнив `git commit`:
```git
$ git add *.c 
$ git add LICENSE 
$ git commit -m 'Initial project version'
```

***Клонирование существующего репозитория***

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду `git clone`.
Клонирование репозитория осуществляется командой `git clone` . Например, если вы хотите клонировать библиотеку libgit2, вы можете сделать это следующим образом:
```git
$ git clone https://github.com/libgit2/libgit2
```
Для того, чтобы клонировать репозиторий в каталог с **именем, отличающимся от libgit2**, необходимо указать желаемое имя, как параметр командной строки:
```git
$ git clone https://github.com/libgit2/libgit2 mylibgit
```
В Git реализовано **несколько транспортных протоколов**, которые вы можете использовать: https://, git:// или же user@server:path/to/repo.git.

***Запись изменений в репозиторий***

Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (**отслеживаемые**) и нет (**неотслеживаемые**). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть **неизменёнными, изменёнными или подготовленными к коммиту**. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется:
![[Pasted image 20211207162642.png]]

# ***Определение состояния файлов***

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:
```git
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Предположим, вы добавили в свой проект новый файл, простой файл README. Если этого файла раньше не было, и вы выполните git status, вы увидите свой неотслеживаемый файл вот так:
```git
$ echo 'My Project' > README
$ git status On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
	(use "git add ..." to include in what will be committed)
	README 
nothing added to commit but untracked files present (use "git add" to track)
```

***Отслеживание новых файлов***

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`.
```git\
$ git add README
```
Если вы снова выполните команду `status`, то увидите, что файл README теперь отслеживаемый и добавлен в индекс:
```git
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
	(use "git restore --staged ..." to unstage)
	new file: README
```

***Индексация измененных файлов***

Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый файл CONTRIBUTING.md и после этого снова выполните команду `git status`, то результат будет примерно следующим:
```git
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:   
	(use "git reset HEAD ..." to unstage)   
	new file: README 
Changes not staged for commit:   
	(use "git add ..." to update what will be committed)   
	(use "git checkout -- ..." to discard changes in working directory)   
	modified: CONTRIBUTING.md
```
Файл CONTRIBUTING.md находится в секции «Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`.
```git
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:   
	(use "git reset HEAD ..." to unstage)   
	new file: README   
	modified: CONTRIBUTING.md
```
Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в CONTRIBUTING.md до коммита. **Если вы изменили файл после выполнения `git add`**, вам придётся снова выполнить `git add`, чтобы проиндексировать последнюю версию файла.

# ***Игнорирование файлов***

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл `.gitignore.` с перечислением шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:
```git
$ cat .gitignore 
*.[oa] 
*~
```
**Первая строка** предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» — объектные и архивные файлы, которые могут появиться во время сборки кода. **Вторая строка** предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid.
*Полезный пример* файла `.gitignore`:
```git
# Исключить все файлы с расширение .a
*.a
# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a 
# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO 
# Игнорировать все файлы в каталоге build/
build/ 
# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt 
# Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt
```
[Ссылка на полный список примеров .gitignore файлов](https://github.com/github/gitignore)

***Просмотр индексированных и неиндексированных изменений***

Используйте `git diff` для просмотра непроиндексированных изменений, а также `git diff --cached` для просмотра проиндексированных изменений (--staged и --cached синонимы).

# ***Коммит изменений ***

Простейший способ зафиксировать изменения — это набрать `git commit`:
```git
$ git commit
```
Вы можете набрать свой комментарий к коммиту в командной строке вместе с командой `commit`, указав его после параметра `-m`, как в следующем примере:
```git
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
2 files changed, 2 insertions(+)  
create mode 100644 README
```
Вы можете видеть, что коммит вывел вам немного **информации** о себе: на какую ветку вы выполнили коммит (**master**), какая контрольная сумма SHA-1 у этого коммита (**463dc4f**), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.

Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.

***Игнорирование индексации***

Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра `-a` в команду `git commit` заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без `git add`.

# ***Удаление файлов***

Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса), а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».
Если вы **просто удалите файл** из своего рабочего каталога, он будет показан в секции «Changes not staged for commit» (измененные, но не проиндексированные) вывода команды `git status`:
```git
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
	(use "git add/rm ..." to update what will be committed)
	(use "git checkout -- ..." to discard changes in working directory)   
		deleted: PROJECTS.md 
no changes added to commit (use "git add" and/or "git commit -a")
```
Затем, если выполните команду `git rm`, удаление файла попадет в индекс:
```git
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
	(use "git reset HEAD ..." to unstage)   
	
	deleted: PROJECTS.md
```
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — **это удалить файл из индекса, оставив его при этом в рабочем каталоге**. Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это особенно полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию `--cached`:
```git
$ git rm --cached README
```

# ***Просмотр истории коммитов***

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда `git log`.
Если запустить команду git log в каталоге клонированного проекта, вы увидите следующий вывод:
```git
$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon
Date: Mon Mar 17 21:52:11 2008 -0700

	Change version number
	
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon
Date: Sat Mar 15 10:31:28 2008 -0700

	Initial commit
```
По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху.

Команда `git log` имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них:
1. Одним из самых полезных аргументов является `-p` или `--patch`, который показывает разницу (выводит патч), внесенную в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр -2 для вывода только двух записей.
2. Если вы хотите увидеть сокращенную статистику для каждого коммита, вы можете использовать опцию `--stat`. Опция `--stat` печатает под каждым из коммитов список и количество измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено. В конце можно увидеть суммарную таблицу изменений.
3. Следующей действительно полезной опцией является`--pretty`. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения. Опция oneline выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. **Наиболее интересной опцией** является format, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для 44 автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git:
```git
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : Change version number 085bb3b - Scott Chacon, 6 years ago : Remove unnecessary test a11bef0 - Scott Chacon, 6 years ago : Initial commit
```
Полезные опции для git log --pretty=format:

![[Pasted image 20211207171245.png]]

# ***Операции отмены***

не все операции отмены в свою очередь можно отменить! Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите **переделать коммит** — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр `--amend`:
```git
$ git commit --amend
```
Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:
```git
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
```

***Отмена индексации файла***

Например, вы изменили два файла и хотите добавить их в разные коммиты, но случайно выполнили команду git add * и добавили в индекс оба. Как исключить из индекса один из них? Команда git status напомнит вам!
Прямо под текстом «Changes to be committed» говорится: используйте `git reset HEAD <file>` для исключения из индекса.

Доступна ещё одна команда: `git restore --staged <file>` для отмены индексации файла.

***Отмена изменений в файле***

Что делать, если вы поняли, что не хотите сохранять свои изменения файла? Как можно просто **отменить изменения** в нём — вернуть к тому состоянию, которое было в последнем коммите (или к начальному после клонирования, или еще как-то полученному)? Нам повезло, что`git status` подсказывает и это тоже.
Например:
```git
Changes not staged for commit:
	(use "git add ..." to update what will be committed) 
	(use "git checkout -- ..." to discard changes in working directory)   
		modified: CONTRIBUTING.md
```
Здесь явно сказано, как отменить существующие изменеий. Давайте так и сделаем:
```git
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed: 
	(use "git reset HEAD ..." to unstage)   
	renamed: README.md -> README
```
Откат изменений был выполнен!
Доступна ещё одна команда: `git restore <file>` для отмены изменений файла (до последнего коммита).
Помните, все **что попало в коммит** почти всегда Git может восстановить.

# ***Работа с удаленными репозиториями***

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду`git remote`. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум `origin` — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.
Вы можете также указать ключ `-v`, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию.

***Добавление удалённых репозиториев***

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду `git remote add <shortname> <>url` :
```git
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
```

***Получение изменений из удалённого репозитория - Fetch и Pull***

Для получения данных из удалённых проектов, следует выполнить:
```git
$ git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда `clone` автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, `git fetch origin` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

***Отправка изменений в удаленный репозиторий (Push)***

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: `git push` . Чтобы отправить вашу ветку *master* на сервер *origin* (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
```git
$ git push origin master
```

***Удаление и переименование удаленных репозиториев***

Для переименования удалённого репозитория можно выполнить `git remote rename`. Например, если вы хотите переименовать *pb* в *paul*, вы можете это сделать при помощи `git remote rename`:
```git
$ git remote rename pb paul
$ git remote
origin
paul
```
Если по какой-то причине вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать `git remote rm`:
```git
$ git remote remove paul
$ git remote
origin
```
При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

**Глава 2 - Ветвление в Git**

***Создание новой ветки***

Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем `testing`. Вы можете это сделать командой `git branch` :
```git
$ git branch testing
```
В результате создаётся новый указатель на текущий коммит.
![[Pasted image 20211209151000.png]]
Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель `HEAD`. В Git — это указатель на текущую локальную ветку. В нашем случае мы все еще находимся в ветке `master`. Команда `git branch` только создаёт новую ветку, но не переключает на неё.
![[Pasted image 20211209150942.png]]
Вы можете легко это увидеть при помощи простой команды `git log`, которая покажет вам куда указывают указатели веток. Эта опция называется `--decorate`:
```git
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the
central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions 98ca9 Initial commit
```

***Переключение веток***

Для переключения на существующую ветку выполните команду `git checkout`. Давайте переключимся на ветку `testing`:
```git
$ git checkout testing
```
В результате указатель `HEAD` переместится на ветку `testing`.
![[Pasted image 20211209151221.png]]
Какой в этом смысл? Давайте сделаем ещё один коммит:
```git
$ vim test.rb
$ git commit -a -m 'made a change'
```
![[Pasted image 20211209151318.png]]
Интересная ситуация: указатель на ветку `testing` переместился вперёд, а master указывает на тот же коммит, где вы были до переключения веток командой `git checkout`. Давайте переключимся назад на ветку `master`:
```git
$ git checkout master
```

**Заметка:**
Для просмотра истории коммитов другой ветки необходимо явно указать её имя: `git log testing` Чтобы посмотреть историю по всем веткам — выполните команду с дополнительным флагом: `git log --all`.

![[Pasted image 20211209151558.png]]
Эта команда сделала две вещи: переместила указатель `HEAD` назад на ветку `master` и вернула файлы в рабочем каталоге в то состояние, на снимок которого указывает `master`. Это также означает, что **все вносимые с этого момента изменения будут относиться к старой версии проекта**. Другими словами, вы откатили все изменения ветки `testing` и можете продолжать в другом направлении.

*Переключение веток меняет файлы в рабочем каталоге*
Важно запомнить, что при переключении веток в Git происходит изменение файлов в рабочем каталоге. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку. Если Git по каким-то причинам не может этого сделать — он не позволит вам переключиться вообще.
Сделаем пару изменений  и создадим очередной коммит:
```git
$ vim test.rb
$ git commit -a -m 'made other changes'
```
Теперь история вашего проекта разошлась. Вы создали ветку и переключились на нее, поработали, а затем вернулись в основную ветку и поработали в ней. Эти изменения изолированы друг от друга: вы можете свободно переключаться туда и обратно, а когда понадобится — объединить их. И все это делается простыми командами: `branch`, `checkout` и `commit`.
![[Pasted image 20211209151859.png]]
Все описанные действия можно визуализировать с помощью команды `git log`. Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду `git log --oneline --decorate --graph --all`.

***Одновременное создание новой ветки и переключение на неё***

Как правило, при создании новой ветки вы хотите сразу на неё переключиться — это можно сделать используя команду `git checkout -b <newbranchname>`.

***Основы ветвления и слияния***

Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в вашем проекте. Ваша работа построена так: 
1. Вы работаете над сайтом. 
2. Вы создаете ветку для новой статьи, которую вы пишете. 
3. Вы работаете в этой ветке. В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая скорейшего исправления.
Ваши действия:
1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку, где вы пишете статью и продолжить работать.

Чтобы слить ветки, нужно всего лишь написать команду `git merge <branchname>`, предварительно переключившись на ту ветку, в которую вы хотите включить изменения.
После исправления ошибки с помощью добавления новой ветки и после того, как вы "слили" её с основной, эту ветку можно уже удалить, прописав команду `git branch -d hotfix`.