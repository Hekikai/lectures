Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

-   `setTimeout` позволяет вызвать функцию **один раз** через определённый интервал времени.
-   `setInterval` позволяет вызывать функцию **регулярно**, повторяя вызов через определённый интервал времени.

Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.

**setTimeout**

Синтаксис:
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
Параметры:

- `func|code`
Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.

- `delay`
Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

- `arg1`, `arg2`…
Аргументы, передаваемые в функцию (не поддерживается в IE9-)

Например, данный код вызывает `sayHi()` спустя одну секунду:
```js
function sayHi() {
	alert('Привет'); 
} 

setTimeout(sayHi, 1000);
```
С аргументами:
```js
function sayHi(phrase, who) {
	alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```

**Отмена через clearTimeout**

Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```

**setInterval**

Метод `setInterval` имеет такой же синтаксис как `setTimeout`:
```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```
Все аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что **функция запускается не один раз**, а периодически через указанный интервал времени.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.
**Во время показа `alert` время тоже идет!**

**Рекурсивный setTimeout**

Есть два способа запускать что-то регулярно.

Один из них `setInterval`. Другим является рекурсивный `setTimeout`. Например:
```js
/** вместо:
let timeId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
	alert('tick');
	timerIt = setTimeout(tick,2000); // (**)
}, 2000);
```
Метод `setTimeout` выше планирует следующий вызов прямо после окончания текущего `(*)`.

Рекурсивный `setTimeout` – более гибкий метод, чем `setInterval`. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.

Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд… Вот псевдокод:
```js
let delay = 5000;

let timerId = setTimeout(function request() {
	...отправить запрос...
	
	if(ошибка запроса из-за перегрузки сервера){
		delay *= 2;
	}
	
	timerId = setTimeout(request, delay);
	
}, delay);
```
А если функции, которые мы планируем, ресурсоёмкие и требуют времени, то мы можем измерить время, затраченное на выполнение, и спланировать следующий вызов раньше или позже.

**Рекурсивный `setTimeout` позволяет задать задержку между выполнениями более точно, чем `setInterval`.**

**Рекурсивный`setTimeout` гарантирует фиксированную задержку.**

Когда функция передаётся в `setInterval/setTimeout`, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на неё нет других ссылок.
Для `setInterval` функция остаётся в памяти до тех пор, пока не будет вызван `clearInterval`.

Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.

**setTimeout с нулевой задержкой**

Особый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.

Это планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.

Так вызов функции будет запланирован сразу после выполнения текущего кода.

Например, этот код выводит «Привет» и затем сразу «Мир»:
```js
setTimeout(() => alert("Мир"));

alert("Привет");
```
Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь» только после того, как текущий код завершится. Поэтому `"Привет"` выводится первым, а `"Мир"` – после него.

**Минимальная задержка вложенных таймеров в браузере**

В браузере есть ограничение на то, как часто внутренние счётчики могут выполняться. В [стандарте HTML5](https://www.w3.org/TR/html5/webappapis.html#timers) говорится: «**после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.**».
Это ограничение существует давно, многие скрипты полагаются на него, поэтому оно сохраняется по историческим причинам.