**Деструктурирующее присваивание** – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.

**Деструктурузация массива**

Пример деструктуризации массива:
```js
let arr = ["Ilya", "Kantor"]
// Записывает firstName = arr[0], surname = arr[1]
let [firstName, surname] = arr;
```
Теперь мы можем использовать переменные вместо элементов массива.

Отлично смотрится в сочетании со `split` или другими методами, возвращающими массив:
```js
let [firstName, surname] = "Ilya Kantor".split(' ');
```
**Деструктуризация не разрушает правую часть** - она просто позволяет скопировать нужные значения в переменные. 
Просто короткий вариант записи :)
```js
// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
```

**Можно пропускать элементы**, используя запятую:
```js
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(title); // Consul
```

Деструктуризация **работает со всеми итерируемыми объектами**, так что справа могут стоять не только массивы.
```js
let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);
```

С левой стороны работает ещё лучше - вы можете **присваивать значения чему угодно**! Например, задавать свойства и их значения в объекте:
```js
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
```

**Цикл с .entries()** (См. также: [[Object.keys, values, entries]])

Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:
```js
let user = { 
	name: "John", 
	age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
	alert(`${key}:${value}`); // name:John, затем age:30
}
```

**Остаточные параметры «…»**

Eсли мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие (`"..."`):
```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert (name1); // Julius
alert (name2); // Caesar
// Обратите внимание, что `rest` является массивом!

alert(rest[0]);     // Consul
alert(rest[1]);     // of the Roman Republic
alert(rest.length); // 2
```
Переменная `rest` является массивом из оставшихся элементов. Вместо `rest` можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.
Значениями по умолчанию могут быть даже сложными выражениями или функциями. Они выполнятся, только если значения отсутствуют.

**Деструктуризация объекта**
Деструктурирующее присваивание также работает с объектами.

Синтаксис:
```js
let {var1, var2} = {var1:…, var2:…}
```
У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в `{...}`.
 Например:
 ```js
let options = { 
	title: "Menu",
	width: 100,
	height: 200
}; 

let {title, width, height} = options;

alert(title); // Menu 
alert(width); // 100 
alert(height); // 200
 ```
 Свойства `options.title`, `options.width` и `options.height` присваиваются соответствующим переменным. Порядок не имеет значения. Вот так – тоже работает:
 ```js
 // изменён порядок в let {...}
 let {height, width, title} = { title: "Menu", height: 200, width: 100 }
 ```
 Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.

**Если мы хотим присвоить свойство объекта переменной с другим названием**, например, свойство `options.width` присвоить переменной `w`, то мы можем использовать двоеточие:
```js
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
```
Двоеточие показывает **«что : куда идёт»**. В примере выше свойство `width` сохраняется в переменную `w`, свойство `height` сохраняется в `h`, а `title` присваивается одноимённой переменной.
Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.

**Остаток объекта «…»**

Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
**Можно использовать троеточие**, как и для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.

Выглядит так:
```js
let options = { 
	title: "Menu",
	width: 100,
	height: 200
}; 
// title = свойство с именем title
// rest = объект с остальными свойствами

let {title, ...rest} = options;

// Cейчас title="Menu", rest={height: 200, width: 100}
alert(rest.height); // 200
alert(rest.width);  // 100
```

**Вложенная деструктуризация**

Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.

В приведённом ниже коде `options` хранит другой объект в свойстве `size` и массив в свойстве `items`. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:
```js
let options = { 
	size: {
		width: 100,
		height: 200
	}, 
	items: ["Cake", "Donut"],
	extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
	size: { // положим size сюда
		width,
		height
	}, 
	items: [item1, item2], // добавим элементы к items
	title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;
```
Весь объект `options`, кроме свойства `extra`, которое в левой части отсутствует, присваивается в соответствующие переменные.
В итоге у нас есть `width`, `height`, `item1`, `item2` и `title` со значением по умолчанию.

Заметим, что переменные для `size` и `items` отсутствуют, так как мы взяли сразу их содержимое.

**Умные параметры функций**

Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов. Представьте себе функцию, которая создаёт меню. Она может иметь ширину, высоту, заголовок, список элементов и так далее.

Вот так – плохой способ писать подобные функции:
```js
function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
// ... 
}
```
В реальной жизни проблема заключается в том, как запомнить порядок всех аргументов. Обычно IDE пытаются помочь нам, особенно если код хорошо документирован, но всё же… Другая проблема заключается в том, как вызвать функцию, когда большинство параметров передавать не надо, и значения по умолчанию вполне подходят.

Разве что вот так?
```js
// undefined там, где подходят значения по умолчанию 
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
```
Это выглядит ужасно. И становится нечитаемым, когда мы имеем дело с большим количеством параметров.

На помощь приходит деструктуризация!

Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
```js
// мы передаём объект в функцию
let options = {
	title: "My menu",
	items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные
function showMenu ({title = 'Untitled', width = 200, height = 100, items = []}) {
	// title, items – взято из options,
	// width, height – используются значения по умолчанию
	alert( `${title} ${width} ${height}` ); // My Menu 200 100
	alert( items ); // Item1, Item2
}

showMenu(options);
```
Мы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием!
Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в `showMenu()` будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
```js
showMenu({}); // ок, все значения - по умолчанию

showMenu(); // так была бы ошибка
```
Мы можем исправить это, сделав `{}` значением по умолчанию для всего объекта параметров:
```js
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
	alert( `${title} ${width} ${height}` );
} 

showMenu(); // Menu 100 200
```
В приведённом выше коде весь объект аргументов по умолчанию равен `{}`, поэтому всегда есть что-то, что можно деструктурировать.