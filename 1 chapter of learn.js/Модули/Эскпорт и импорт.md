Директивы экспорт и импорт имеют несколько вариантов вызова.

**Экспорт до объявления**

Мы можем пометить любое объявление как экспортируемое, разместив `export` перед ним, будь то переменная, функция или класс. 

Лучше не ставить точку с запятой после экспорта класса или функции. 

**Экспорт отдельно от объявления**

Также можно написать `export` отдельно.

Здесь мы сначала объявляем, а затем экспортируем:
```js
// say.js

function sayHi(user) {
	console.log(`Hello, ${user}!`);
}

function sayBye(user) {
	console.log(`Bye, ${user}!`);
}

export {sayHi, sayBye}; // список экспортируемых переменных
```

…Или, технически, мы также можем расположить `export` выше функций.

**Импорт**

Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках `import {...}`, например вот так:
```js
// main.js
import {sayHi, sayBye} from './say.js';
```

Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя `import * as <obj>`. Например:
```js
import * as say from './say.js';
```

На первый взгляд «импортировать всё» выглядит очень удобно, не надо писать лишнего, зачем нам вообще может понадобиться явно перечислять список того, что нужно импортировать?

Для этого есть несколько причин.
1.Современные инструменты сборки ([webpack](http://webpack.github.io/) и другие) собирают модули вместе и оптимизируют их, ускоряя загрузку и удаляя неиспользуемый код.
Предположим, мы добавили в наш проект стороннюю библиотеку `say.js` с множеством функций. Теперь, если из этой библиотеки в проекте мы используем только одну функцию. ...Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
2. Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: `sayHi()` вместо `say.sayHi()`.
3. Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.

**Импорт "как"**

Мы также можем использовать `as`, чтобы импортировать под другими именами.

Например, для краткости импортируем `sayHi` в локальную переменную `hi`, а `sayBye` импортируем как `bye`:
```js
// main.js
import {sayHi as hi, sayBye as bye} from './say.js';
```

**Экспортировать "как"**

Аналогичный синтаксис существует и для `export`.

Давайте экспортируем функции, как `hi` и `bye`:
```js
// say.js
...
export {sayHi as hi, sayBye as bye};
```

Теперь `hi` и `bye` – официальные имена для внешнего кода, их нужно использовать при импорте:
```js
// main.js
import * as say from './say.js';

say.hi('John');  // Hello, John!
say.bye('John'); // Bye, John!
```

**Экспорт по умолчанию**

На практике модули встречаются в основном одного из двух типов:

1.  Модуль, содержащий библиотеку или набор функций, как `say.js` выше.
2.  Модуль, который объявляет что-то одно, например модуль `user.js` экспортирует только `class User`.

По большей части, удобнее второй подход, когда каждая «вещь» находится в своём собственном модуле.

Естественно, требуется много файлов, если для всего делать отдельный модуль, но это не проблема. Так даже удобнее: навигация по проекту становится проще, особенно, если у файлов хорошие имена, и они структурированы по папкам.

Модули предоставляют специальный синтаксис `export default` («экспорт по умолчанию») для второго подхода.

Ставим `export default` перед тем, что нужно экспортировать:
```js
// user.js
export default class User {
	constructor(name) {
		this.name = name;
	}
}
```

Заметим, в файле может быть не более одного `export default`.

…И потом импортируем без фигурных скобок:
```js
// main.js
import User from './user.js'; // не {User}, а просто User
```

Импорты без фигурных скобок выглядят красивее. Обычная ошибка начинающих: забывать про фигурные скобки. Запомним: фигурные скобки необходимы в случае именованных экспортов, для `export default` они не нужны.

Технически в одном модуле может быть как экспорт по умолчанию, так и именованные экспорты, но на практике обычно их не смешивают. То есть, в модуле находятся либо именованные экспорты, либо один экспорт по умолчанию.

Так как в файле может быть максимум один `export default`, то экспортируемая сущность не обязана иметь имя.

**Имя "default"**

В некоторых ситуациях для обозначения экспорта по умолчанию в качестве имени используется `default`.

Например, чтобы экспортировать функцию отдельно от её объявления:
```js
function sayHi(user) {
	console.log(`Hello, ${user}!`);
}

// то же самое, как если бы мы добавили "export default" перед функцией
export {sayHi as default};
```

Или, ещё ситуация, давайте представим следующее: модуль `user.js` экспортирует одну сущность «по умолчанию» и несколько именованных (редкий, но возможный случай):
```js
// user.js

export default class User {
	constructor(name) {
		this.name = name;
	}

}

export function sayHi(user) {
	console.log(`Hello, ${user}!`);
}
```

Вот как импортировать экспорт по умолчанию вместе с именованным экспортом:
```js
// main.js

import {default as User, sayHi} from './user.js';
```

И, наконец, если мы импортируем всё как объект `import *`, тогда его свойство `default` – как раз и будет экспортом по умолчанию.

**Довод против экспортов по умолчанию**

Именованные экспорты «включают в себя» своё имя. Эта информация является частью модуля, говорит нам, что именно экспортируется.

Именованные экспорты вынуждают нас использовать правильное имя при импорте.

…В то время как для экспорта по умолчанию мы выбираем любое имя при импорте. Так что члены команды могут использовать разные имена для импорта одной и той же вещи, и это не очень хорошо.

Обычно, чтобы избежать этого и соблюсти единообразие кода, есть правило: имена импортируемых переменных должны соответствовать именам файлов. Вот так:
```js
import User from './user.js';
import LoginForm from './loginForm.js';
import func from '/path/to/func.js';
```

Тем не менее, в некоторых командах это считают серьёзным доводом против экспортов по умолчанию и предпочитают использовать именованные экспорты везде. Даже если экспортируется только одна вещь, она всё равно экспортируется с именем, без использования `default`.

Это также немного упрощает реэкспорт.

**Реэкспорт**

Синтаксис «реэкспорта» `export ... from ...` позволяет импортировать что-то и тут же экспортировать, возможно под другим именем, вот так:
```js
export {sayHi} from './say.js'; // реэкспортировать sayHi

export {default as User} from './user.js'; // реэкспортировать default
```

Зачем это нужно? Рассмотрим практический пример использования.

Представим, что мы пишем «пакет»: папку со множеством модулей, из которой часть функциональности экспортируется наружу (инструменты вроде NPM позволяют нам публиковать и распространять такие пакеты), а многие модули – просто вспомогательные, для внутреннего использования в других модулях пакета.

Структура файлов может быть такой:
```js
auth/
	index.js
	user.js
	tests.js
		providers/
			github.js
			facebook.js
```

Мы бы хотели сделать функциональность нашего пакета доступной через единую точку входа: «главный файл» `auth/index.js`. Чтобы можно было использовать её следующим образом:
```js
import {login, logout} from 'auth/index.js'
```

Идея в том, что внешние разработчики, которые будут использовать наш пакет, не должны разбираться с его внутренней структурой, рыться в файлах внутри нашего пакета. Всё, что нужно, мы экспортируем в `auth/index.js`, а остальное скрываем от любопытных взглядов.

Так как нужная функциональность может быть разбросана по модулям нашего пакета, мы можем импортировать их в `auth/index.js` и тут же экспортировать наружу.
```js
// auth/index.js

// импортировать login/logout и тут же экспортировать
import {login, logout} from './helpers.js';
export {login, logout};

// импортировать экспорт по умолчанию как User и тут же экспортировать
import User from './user.js';
export {User};
```

Теперь пользователи нашего пакета могут писать `import {login} from "auth/index.js"`.

Запись `export ... from ...`– это просто более короткий вариант такого импорта-экспорта:
```js
// auth/index.js

// импортировать login/logout и тут же экспортировать

export{login, logout} from './helpers.js';

// импортировать экспорт по умолчанию как User и тут же экспортировать
export {default as User} from './user.js';
```

**Реэскпорт экспорта по умолчанию**

При реэкспорте экспорт по умолчанию нужно обрабатывать особым образом.

Например, у нас есть `user.js`, из которого мы хотим реэкспортировать класс `User`:
```js
// user.js
export default class User {
	//...
}
```

1. `export User from './user.js'` не будет работать. Казалось бы, что такого? Но возникнет синтаксическая ошибка!
Чтобы реэкспортировать экспорт по умолчанию, мы должны написать `export {default as User}`, как в примере выше. Такая вот особенность синтаксиса.
    
2.  `export * from './user.js'` реэкспортирует только именованные экспорты, исключая экспорт по умолчанию.

Если мы хотим реэкспортировать и именованные экспорты и экспорт по умолчанию, то понадобятся две инструкции:
```js
export * from './user.js'; // для реэкспорта именованных экспортов
export {default} from './user.js'; // для реэкспорта по умолчанию
```

Такое особое поведение реэкспорта с экспортом по умолчанию – одна из причин того, почему некоторые разработчики их не любят.