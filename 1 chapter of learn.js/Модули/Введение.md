По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». Модуль обычно содержит класс или библиотеку с функциями.

Долгое время в JavaScript отсутствовал синтаксис модулей на уровне языка. Это не было проблемой, потому что первые скрипты были маленькими и простыми. В модулях не было необходимости.

**Что такое модуль?**

Модуль - это просто файл. Один скрипт - один модуль. Модули могул загружаться друг друга или же делиться функциональностью через директивы `import` и `export`:
- `export` отмечает функции и переменные, которые должны быть доступны вне текущего модуля.
- `import` позволяет импортировать функциональность из других модулей.

То есть мы экспортируем то, что нам нужно "отдать", а других файлах "принимаем" это через `import`.

У каждого модуля своя область видимости! А в браузере существует независимая область видимости для каждого скрипта `<script type="module">`.

**Код в модуле выполняется один раз при импорте**

Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.

Представим ситуацию, что модуль экспортирует какой-нибудь объект:
```js
export let admin = {
	name: "John"
}
```

Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект `admin` будет создан и в дальнейшем будет передан всем импортёрам.

Все импортёры получат один-единственный объект `admin`:
```js
// 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// 2.js
import {admin} from '.admin.js';
console.log(admin.name); // Pete

// Оба файла, 1.js и 2.js, импортируют один и тот же объект 
// Изменения, сделанные в 1.js, будут видны в 2.js
```

Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте `admin`, то другие модули тоже увидят эти изменения.

Такое поведение позволяет _конфигурировать_ модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.

**import.meta**

Объект `import.meta` содержит информацию о текущем модуле.
Содержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML:
```html
<script type="module">
	console.log(import.meta.url); // ссылка на html-страницу
</script>
```

**В модуле this не определен**
Это незначительная особенность, но для полноты картины нам нужно упомянуть об этом.

В модуле на верхнем уровне `this` не определён (undefined).

Сравним с не-модульными скриптами, там `this` – глобальный объект:
```html
<script> 
	alert(this); // window 
</script> 

<script type="module"> 
	alert(this); // undefined 
</script>
```

**Внешние скрипты**

Внешние скрипты с атрибутом `type="module"` имеют два отличия:
1. Внешние скрипты с одинаковым атрибутом `src` запускаются только один раз
```html
<!-- скрипт my.js загрузится и будет выполнен только один раз -->
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```
2. Внешний скрипт, который загружается с другого домена, требует указания заголовков [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS). Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок `Access-Control-Allow-Origin` означающий, что загрузка скрипта разрешена.
```html
<!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->
<!-- иначе, скрипт не выполнится -->
<script type="module" src="http://another-site.com/their.js"></script>
```
Это обеспечивает лучшую безопасность по умолчанию.

**Не допускаются "голые" модули**

Нельзя импортировать файл без относительного или абсолютного путя.
```js
import {sayHi} from 'sayHi'; // Ошибка, "голый" модуль
// путь должен быть, например './sayHi.js' или абсолютный
```

Другие окружения, например Node.js, допускают использование «голых» модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать. Но браузеры пока не поддерживают «голые» модули.

**Совместимость, nomodule**

Старые браузеры не понимают атрибут `type="module"`. Скрипты с неизвестным атрибутом `type` просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута `nomodule`:
```html
<script nomodule>
	<!--...-->
	<!--...-->
</script>
```

**Инструменты сборки**

В реальной жизни модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например [Webpack](https://webpack.js.org/) и после выкладываем код на рабочий сервер.

Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например CSS/HTML-модули.

Сборщик делает следующее:

1.  Берёт «основной» модуль, который мы собираемся поместить в `<script type="module">` в HTML.
2.  Анализирует зависимости (импорты, импорты импортов и так далее)
3.  Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный `import` функцией импорта от сборщика, чтобы всё работало. «Специальные» типы модулей, такие как HTML/CSS тоже поддерживаются.
4.  В процессе могут происходить и другие трансформации и оптимизации кода:
    -   Недостижимый код удаляется.
    -   Неиспользуемые экспорты удаляются («tree-shaking»).
    -   Специфические операторы для разработки, такие как `console` и `debugger`, удаляются.
    -   Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью [Babel](https://babeljs.io/).
    -   Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).

Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют `import/export` на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута `type="module"`, как обычный скрипт:
```html
<!-- Предположим, что мы собрали bundle.js, используя например утилиту Webpack -->
<script src="bundle.js"></script>
```

Хотя и «как есть» модули тоже можно использовать, а сборщик настроить позже при необходимости.