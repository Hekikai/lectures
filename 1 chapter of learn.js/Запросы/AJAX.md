**AJAX** - это модное слово, означающее "**Making an HTTP request from JavaScript without leaving the page**".

`XMLHttpRequest` и `fetch` -это APIs, предоставляемые браузерами, которые позволяют делать запросы HTTP из JavaScript.

Fetch API является современной альтернативой XMLHttpRequest. На основе Fetch можно преобразовывать примеры XHR в гораздо более простой код.

Fetch - чистый, элегантный, простой для понимания и интенсивно используемый в PWA Service Workers. Почему бы вам не использовать его вместо древнего XMLHttpRequest?
К сожалению, веб-разработка никогда не бывает такой четкой. Fetch еще не является полноценной заменой методов Ajax…

**Cookieless по умолчанию**

В отличие от XMLHttpRequest, не все реализации Fetch будут отправлять куки-файлы, поэтому аутентификация вашего приложения может быть неудачной. Проблема может быть исправлена путем изменения параметров инициации, передаваемых во втором аргументе, например:
```js
fetch('http://domain/service', {
	method: 'GET',
	credentials: 'same-origin'
})
```

**Ошибки не отклоняются**

Удивительно, но ошибка HTTP, такая как **404 Page Not Found** или **500 Internal Server Error**, **.catch()** никогда не запускается. Обычно он разрешается с состоянием **response.ok**, установленным в false. 
Отказ происходит только в том случае, если запрос не может быть выполнен, например, сбой сети. Это может усложнить реализацию перехвата ошибок.

**Прогресс загрузки файлов**

Fetch не предоставляет информации о загрузке файлов.

1. ***POST, GET запросы***

GET-запросы лучше использовать тогда, когда страница, созданная именно этим методом, может быть кеширована браузерами. Из этого следует, что метод GET следует использовать для получения данных от сервера и не желательно в запросах, предпологающих внесений изменений в ресурс.

POST-запрос лучше использовать в протиповоложных случаях - т. е. вносить изменение в ресурс (выполнить авторизацию, отправить форму отправления заказа, форму обратной связи). Повторный переход по конечной ссылке не вызовет повторную обработку запроса, так как не будет содержать переданных ранее параметров.

2. ***AJAX***

AJAX - _Asynchronous JavaScript and XML_ - асинхронный JavaScript и XML - это не технология сама по себе, а термин, который описывает подход к использованию существующих технологий вместе. Он включает в себя HTML или XHTML, CSS, JavaScript, DOM, XML, XSLT и объет XMLHttpRequest. Когда эти **технологии объединяются в модель AJAX**, web-приложения способны делать быстрые дополняющие обновления интерфейса пользователя без необходимости полной перезагрузки страницы браузером.

В основе технологии лежит использование нестандартного объекта XMLHttpRequest, необходимого для взаимодействия со скриптами на стороне сервера. Объект может как отправлять, так и получать информацию в различных форматах включая XML, HTML и даже текстовые файлы. Самое привлекательное в AJAX - его асинхронный принцип работы. С помощью его можно **осуществлять взаимодействие с сервером без необходимости перезагрузки страницы.** Это позволяет обновлять содержимое страницы частично, в зависимости от действий пользователя.

**Шаг 1** - как послать HTTP 

Для того, чтобы послать HTTP запрос на сервер используя JavaScript, вам необходим экземпляр класса, который позволит это сделать.
```js
let httpRequest = new XMLHttpRequest();
```

Далее необходимо решить, что вы будете делать после получения ответа сервера. А значит, нужно указать объекту, какая JS функция будет обрабатывать ответ. Это делается путем присваивания свойству *onreadystatechange* имени JS функции, которую вы собираетесь использовать:
```js
httpRequest.onreadystatechange = nameOfFunction;
```

**Важная деталь:** после названия функции нет скобок, так как вы не вызываете её, а просто присваиваем ссылку на эту функцию. В дополнении, вместо указания имени функции, можно использовать возможность JS объявлять функции на лету (так называемые **"анонимные функции"**) и указывать действия, которые тотчас же будут обрабатывать ответ:
```js
htppRequest.onreadystatechange = function(){
	//какой-то код...
}
```

Далее, после того, как вы объявили что будет происходить после получения ответа, вам необходимо сделать запрос. Вы должны вызвать методы класса ==open()== и ==send()==:
```js
httpRequest.open('GET', 'http://example.org/some.file', true);
httpRequest.send();
```
- Первый параметр вызова функции ==open()== - метод HTTP запроса (GET, POST, HEAD и т.п.). Использовать методы стоит в соответствии с HTTP стандартами, иначе некоторые браузеры могут не обработать запрос. Информацию о допустимых HTTP запросах доступна по адресу [W3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html).
- Второй параметр - URL%%сделать статью про URL%%(Uniform Resourse Locator) запрашиваемой страницы. Из соображений безопасности возможность запрашивать страницы сторонних доменов недоступна. Надо убедиться в совпадении доменного имени, а иначе будет ошибка при вызове функции ==open()==. Типичная ошибка при доступе к сайту через *site.ru* является отправка запроса на *www.site.ru.*
- Третий параметр указывает, является ли запрос асинхронным. Если он true, то выполнение JS продолжится во время ожидания ответа сервера. В этом и заключается асинхронность технологии.

Параметром метода ==send()== могу быть любые данные, которые вы хотите послать на сервер. Данные могут быть сформированы в строку запроса:
**name=value&anothername=othervalue&so=on**

Стоит учесть, что если вы хотите отправить данные методом POST, то вы должны изменить MIME-тип запроса с помощью следующей строки:
```js
httpRequest.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
```

Иначе сервер проигнорирует данные отправленные методом POST.

**Шаг 2** - обрабатываем ответ сервера

Функция, которая была указана в JS для обработки ответа запроса, должна что-то делать. Во-первых, функция должна проверять статус запроса. Если **значение переменной статуса 4**, то это означает, что ответ от сервера получен и его можно обрабатывать.
```js
if (httpRequest.readyState === 4) {
	//все в норме, ответ получен
} else {
	//ответа все ещё нет
}
```

Полный список значений readyState таков:
- 0 (uninitialized)
- 1 (loading)
- 2 (loaded)
- 3 (interactive)
- 4 (complete)

Следующее, что нужно проверить, - это статус HTTP-ответа. Все возможные коды можно посмотреть тут: [W3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html). Нам интересен код ответа **200 OK.**
```js
if (httpRequest.status === 200){
	//все в порядке!
} else {
	//с запросом возникли проблемы,
	//например, может быть ответ 404 (Не найдено)
	//или 500 (Внутренняя ошибка сервера)
}
```

Теперь, после проверки состояния запроса и статуса HTTP-ответа, можно делать с данными, полученными от сервера, все что угодно. Есть **два способа получить доступ** к данным:
- httpRequest.responseText - возвращает ответ сервера в виде строки текста.
- httpReques.responseXML - возвращает ответ сервер в виде объекта XMLDocument, который можно обходить, используя функции JS DOM.

*Замечание*: Объявлять переменную httpRequest лучше **локально** в функции, чтобы избежать "состязаний" за то, что кто будет делать.