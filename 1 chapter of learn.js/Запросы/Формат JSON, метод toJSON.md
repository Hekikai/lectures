Допустим, у нас есть сложный объект, и мы хотели бы преобразовать его в строку, чтобы отправить по сети или просто вывести для логирования.

Естественно, такая строка должна включать в себя все важные свойства.
В процессе разработки добавляются новые свойства, старые свойства переименовываются и удаляются. Обновление такого `toString` каждый раз может стать проблемой. Мы могли бы попытаться перебрать свойства в нём, но что, если объект сложный, и в его свойствах имеются вложенные объекты? Мы должны были бы осуществить их преобразование тоже.

К счастью, нет необходимости писать код для обработки всего этого. У задачи есть простое решение.

**JSON.stringify**

[JSON](https://ru.wikipedia.org/wiki/JSON) (JavaScript Object Notation) – это общий формат для представления значений и объектов. Его описание задокументировано в стандарте [RFC 4627](http://tools.ietf.org/html/rfc4627). Первоначально он был создан для JavaScript, но многие другие языки также имеют библиотеки, которые могут работать с ним. Таким образом, JSON легко использовать для обмена данными, когда клиент использует JavaScript, а сервер написан на Ruby/PHP/Java или любом другом языке.
JavaScript предоставляет методы:

-   `JSON.stringify` для преобразования объектов в JSON.
-   `JSON.parse` для преобразования JSON обратно в объект.

Например, здесь мы преобразуем через `JSON.stringify` данные студента:
```js
let student = {
	name: 'John',
	age: 30,
	isAdmin: false,
	courses: ['html', 'css', 'js'],
	wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // => строка!
alert(json);
/* выведет объект в формате JSON:
{
	"name": "John",
	"age": 30,
	"isAdmin": false,
	"courses": ["html", "css", "js"],
	"wife": null
}
*/
```
Метод `JSON.stringify(student)` берёт объект и преобразует его в строку.

Полученная строка `json` называется _JSON-форматированным_ или _сериализованным_ объектом. Мы можем отправить его по сети или поместить в обычное хранилище данных.
Обратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:

-   Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так `'John'` становится `"John"`.
-   Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так `age:30` становится `"age":30`.

`JSON.stringify` может быть применён и к примитивам.
JSON поддерживает следующие типы данных:
-   Объекты `{ ... }`
-   Массивы `[ ... ]`
-   Примитивы:
    -   строки,
    -   числа,
    -   логические значения `true/false`,
    -   `null`.

JSON является независимой от языка спецификацией для данных, поэтому `JSON.stringify` пропускает некоторые специфические свойства объектов JavaScript.
А именно:
-   Свойства-функции (методы).
-   Символьные свойства.
-   Свойства, содержащие `undefined`.

Обычно это нормально. Если это не то, чего мы хотим, то скоро мы увидим, как можно настроить этот процесс.

Самое замечательное, что вложенные объекты поддерживаются и конвертируются автоматически.
**Важное ограничение: не должно быть циклических ссылок.**
Например:
```js
let room = { 
	number: 23 
}; 
let meetup = {
	title: "Conference", 
	participants: ["john", "ann"]
}; 

meetup.place = room; // meetup ссылается на room room.occupiedBy = meetup; // room ссылается на meetup

JSON.stringify(meetup); // Ошибка: Преобразование цикличной 
                        //структуры в JSON
```

**Исключаем и преобразуем: replacer**

Полный синтаксис `JSON.stringify`:
```js
let json = JSON.stringify(value[, replacer, space])
```
- value
Значение для кодирования.
- replacer
Массив свойств для кодирования или функция соответствия `function(key, value)`.
- space
Дополнительное пространство (отступы), используемое для форматирования.

В большинстве случаев `JSON.stringify` используется только с первым аргументом. Но если нам нужно настроить процесс замены, например, отфильтровать циклические ссылки, то можно использовать второй аргумент `JSON.stringify`.

Если мы передадим ему массив свойств, будут закодированы только эти свойства. Но тогда нужно учитывать **вложенные свойства**, а это неудобно, так как получится слишком длинная строка.
К счастью, в качестве `replacer` мы можем использовать функцию, а не массив.

Функция будет вызываться для каждой пары `(key, value)`, и она должна возвращать заменённое значение, которое будет использоваться вместо исходного. Или `undefined`, чтобы пропустить значение.
```js
let room = { 
	number: 23 
}; 

let meetup = { 
	title: "Conference",
	participants: [{name: "John"}, {name: "Alice"}],
	place: room // meetup ссылается на room 
};

room.occupiedBy = meetup;

JSON.stringify(meetup, function replacer(key, value) {
	alert(`${key}: ${value}`);
	return (key == 'occupiedBy') ? undefined : value;
}));
/* пары ключ:значение, которые приходят в replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object] 
name:         Alice 
place:        [object Object]
number:       23
*/
```
Обратите внимание, что функция `replacer` получает каждую пару ключ/значение, включая вложенные объекты и элементы массива. И она применяется рекурсивно. Значение `this` внутри `replacer` – это объект, который содержит текущее свойство.

Первый вызов – особенный. Ему передаётся специальный «объект-обёртка»: `{"": meetup}`. Другими словами, первая `(key, value)` пара имеет пустой ключ, а значением является целевой объект в общем. Вот почему первая строка из примера выше будет `":[object Object]"`.

Идея состоит в том, чтобы дать как можно больше возможностей `replacer` – у него есть возможность проанализировать и заменить/пропустить даже весь объект целиком, если это необходимо.

**Форматирование: space**

Третий аргумент в `JSON.stringify(value, replacer, space)` – это количество пробелов, используемых для удобного форматирования.

Ранее все JSON-форматированные объекты не имели отступов и лишних пробелов. Это нормально, если мы хотим отправить объект по сети. Аргумент `space` используется исключительно для вывода в удобочитаемом виде.

**Пользовательский toJSON**

Как и `toString` для преобразования строк, объект может предоставлять метод `toJSON` для преобразования в JSON. `JSON.stringify` автоматически вызывает его, если он есть.
Например:
```js
let room = { 
	number: 23 
}; 

let meetup = { 
	title: "Conference",
	date: new Date(Date.UTC(2017, 0, 1)),
	room 
}; 

alert( JSON.stringify(meetup) ); 
/* 
	{
	"title":"Conference",
	"date":"2017-01-01T00:00:00.000Z", // (1)
	"room": {"number":23}              // (2) 
	} 
*/
```
Как видим, `date` `(1)` стал строкой. Это потому, что все объекты типа `Date` имеют встроенный метод `toJSON`, который возвращает такую строку.
Теперь давайте добавим собственную реализацию метода `toJSON` в наш объект `room` `(2)`:
```js
let room = {
	number: 23,
	toJSON() {
		return this.number;
	}
};
```

**JSON.parse**

Чтобы декодировать JSON-строку, нам нужен другой метод с именем [JSON.parse](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse).

Синтаксис:
```js
let value = JSON.parse(str, [reviver]);
```
- str
JSON для преобразования в объект.
- reviver
Необязательная функция, которая будет вызываться для каждой пары `(ключ, значение)` и может преобразовывать значение.

JSON может быть настолько сложным, насколько это необходимо, объекты и массивы могут включать другие объекты и массивы. Но они должны быть в том же JSON-формате.

Вот типичные ошибки в написанном от руки JSON (иногда приходится писать его для отладки):
```js
let json = `{ 
	name: "John",       // Ошибка: имя свойства без кавычек 
	"surname": 'Smith',  // Ошибка: одинарные кавычки в
	                     // значении (должны быть двойными)
	'isAdmin': false    // Ошибка: одинарные кавычки в ключе
	                     // (должны быть двойными) 
	"birthday": new Date(2000, 2, 3), // Ошибка: не 
	                     // допускается конструктор "new",
	                     // только значения.
	"friends": [0,1,2,3] // Здесь всё в порядке 
}`;
```
Кроме того, **JSON не поддерживает комментарии**. Добавление комментария в JSON делает его недействительным.

Существует ещё один формат [JSON5](http://json5.org/), который поддерживает ключи без кавычек, комментарии и т.д. Но это самостоятельная библиотека, а не спецификация языка.

Обычный JSON настолько строг не потому, что его разработчики ленивы, а потому, что позволяет легко, надёжно и очень быстро реализовывать алгоритм кодирования и чтения.

**Использование reviver**

Представьте, что мы получили объект `meetup` с сервера в виде строки данных.

Вот такой:
```js
// title: (meetup title), date: (meetup date)

let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
```
…А теперь нам нужно _десериализовать_ её, т.е. снова превратить в объект JavaScript.

Давайте сделаем это, вызвав `JSON.parse`:
```js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
```
Ой, ошибка!
Значением `meetup.date` является строка, а не `Date` объект. Как `JSON.parse` мог знать, что он должен был преобразовать эту строку в `Date`?

Давайте передадим `JSON.parse` функцию восстановления вторым аргументом, которая возвращает все значения «как есть», но `date` станет `Date`:
```js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
	if (key == 'date') return new Date(value);
	return value;
});

alert( meetup.date.getDate() ); // 30 - теперь работает!
```