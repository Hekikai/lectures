`Map` позволяет хранить в себе ссылки на какие-то данные (если у нас в качестве ключа выступает объект), и стоит нам обnullилть ссылку на этот объект, то `Map` не позволит сборщику мусора удалить эту ссылку. Например:
```js
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // перезаписываем ссылку на объект 

// объект john сохранён внутри объекта `Map`,
// он доступен через map.keys()
```
**WeakMap**

`WeakMap` – принципиально другая структура в этом аспекте. Она **не предотвращает удаление объектов сборщиком мусора**, когда эти **объекты выступают в качестве ключей**.
Первое его отличие от `Map` в том, что ключи в `WeakMap` должны быть объектами, а не примитивными значениями:
```js
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // объект в качестве ключа

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка,
//потому что "test" не объект
```
Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта `WeakMap`) автоматически.
```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект 
// объект john удалён из памяти!
```
`WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значения из неё.

В `WeakMap` присутствуют только следующие методы:
-   `weakMap.get(key)`
-   `weakMap.set(key, value)`
-   `weakMap.delete(key)`
-   `weakMap.has(key)`

К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим (как объект `john` в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, _в какой момент произойдёт эта очистка_.

Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз позже. Так что технически количество элементов в коллекции `WeakMap` неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.

Но для чего же нам нужна такая структура данных?

**Пример: дополнительные данные**

В основном, `WeakMap` используется в качестве _дополнительного хранилища данных_.

Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то `WeakMap` – как раз то, что нужно.

Мы кладём эти данные в `WeakMap`, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.
```js
weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы"
// будут автоматически уничтожены
```
Давайте рассмотрим один пример.

Предположим, у нас есть код, который ведёт учёт посещений для пользователей. Информация хранится в коллекции `Map`: объект, представляющий пользователя, является ключом, а количество визитов – значением. Когда пользователь нас покидает (его объект удаляется сборщиком мусора), то больше нет смысла хранить соответствующий счётчик посещений.

Вот пример реализации счётчика посещений с использованием `Map`:
```js
// visitsCount.js
let visitCountMap = new Map();

function countUser (user) {
	let count = visitCountMap.get(user) || 0;
	visitCountMap.set(user, count + 1);
}
```
А вот другая часть кода, возможно, в другом файле, которая использует `countUser`:
```js
// main.js
let john = {name: 'John'};

countUser(john); // Подсчет посещений

// Пользователь ушел
jonh = null;
```
Теперь объект `john` должен быть удалён сборщиком мусора, но он продолжает оставаться в памяти, так как является ключом в `visitsCountMap`.

Нам нужно очищать `visitsCountMap` при удалении объекта пользователя, иначе **коллекция будет бесконечно расти**. Подобная **очистка** может быть **неудобна в реализации при сложной архитектуре приложения**.

Проблемы можно избежать, если использовать `WeakMap`:
```js
// visitsCount.js
let visitCountMap = new WeakMap();

function countUser (user) {
	let count = visitCountMap.get(user) || 0;
	visitCountMap.set(user, count + 1);
}
```

**Применение для кеширования**

Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его.

**WeakSet**

Коллекция `WeakSet` ведёт себя похоже:

-   Она аналогична `Set`, но мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
-   Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
-   Как и `Set`, она поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве `WeakSet` может что-то сказать нам об объекте.
Наиболее значительным ограничением `WeakMap` и `WeakSet` является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает `WeakMap/WeakSet` выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.

См. также:
[[Map и Set]]