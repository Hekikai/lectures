Перебираемые (или итерируемые) объекты - это концепция, которая позволяет использовать любой объект в цикле `for...of`.
Выводы по теме (для повторения)[^1]

[^1]: Выводы:
	- Чтобы пройтись по объекту, он должен быть итерируемым
	- Реализуете Symbol.iterator(), который возвращает объект
	- Работаете с полученным объектом так, как вы хотите
	- Можете итерироваться по объекту, profit!
	- Если вам удобнее было бы работать с итерируемым объектом как с массивом, тогда используйте Array.from(obj). Правда без реализованного Symbol.iterator() ничего работать не будет :)

***Symbol.iterator***
Создадим перебираемый объект.
```js
let range = { 
	from: 1, 
	to: 5
};

// Мы хотим, чтобы работал for..of:
// for(let num of range) ... num = 1, 2, 3, 4, 5
```
Чтобы сделать `range` итерируемым (и позволить `for..of` работать с ним), нам нужно добавить в объект метод с именем `Symbol.iterator` (специальный встроенный `Symbol`, созданный как раз для этого).
План по пунктам:
1. Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть _итератор_ – объект с методом `next`.
2. Дальше `for..of` работает _только с этим возвращённым объектом_.
3. Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.
4. Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что итерация закончена, в противном случае `value` содержит очередное значение.

Пример простой реализации [*Symbol.iterator*]:
```js
let range = {
 from: 1,
 to: 5,
}

range[Symbol.iterator] = function () {

	return {
		current: this.from,
		last: this.to,

	next() {

		if (this.current <= this.last) {
			return { done: false, value: this.current++ };
		} else {
			return { done: true };
		}
	 }
  }
};
```
Ключевая особенность итераторов:
-   У самого `range` нет метода `next()`.
-   Вместо этого другой объект, так называемый «итератор», создаётся вызовом `range[Symbol.iterator]()`, и именно его `next()` генерирует значения.

***Строка - перебираемый объект***

Для строки `for..of` перебирает символы (работает даже с суррогатными парами!):
```js
for (let char of "test") {
	// срабатывает 4 раза: по одному для каждого символа
	alert( char ); // t, затем e, затем s, затем t
}
``` 

***Явный вызов итератора***

Чтобы понять устройство итераторов чуть глубже, давайте посмотрим, как их использовать явно.

Мы будем перебирать строку точно так же, как цикл `for..of`, но вручную, прямыми вызовами. Нижеприведённый код получает строковый итератор и берёт из него значения:
```js
let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while(true){
	let result = iterator.next();
	if(result.done) break;
	alert(result.value); // выводит символы друг за дружкой
}
```
Такое редком необходимо, но может понадобиться, чтобы детерминировать процесс по кускам.

***Итерируемые объекты и псевдомассивы***

Есть два официальных термина, которые очень похожи, но в то же время сильно отличаются. Разницу их стоит понять и осознать:

- **Итерируемые объекты** - это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
- **Псевдомассивы** - это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.

Сразу пример: троки итерируемы (для них работает `for..of`) и являются псевдомассивами (они индексированы и есть `length`).
**Но!** Итерируемый объект может не быть псевдомассивом. И наоборот: псевдомассив может не быть итерируемым. 

Например, объект `range` из примера выше – **итерируемый**, но не является псевдомассивом, потому что у него нет индексированных свойств и `length`.
А вот, ниже, объект, который является **псевдомассивом**, но его нельзя итерировать:
```js
let arrayLike = {
	0: 'Hello',
	1: 'World',
	length: 2,
};
// Ошибка (отсутствует Symbol.iterator)
for(let piece of arrayLike){}
```
Что у них общего? И итерируемые объекты, и псевдомассивы – это обычно _не массивы_, у них нет методов `push`, `pop` и т.д. Довольно неудобно, если у нас есть такой объект и мы хотим работать с ним как с массивом. Например, мы хотели бы работать с `range`, используя методы массивов. Как этого достичь?

***Array.from***

Есть универсальный метод [Array.from](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from), который принимает итерируемый объект или псевдомассив и делает из него «настоящий» `Array`. После этого мы уже можем использовать методы массивов.
Допустим:
```js
let arrayLike = {
	0: 'Hello',
	1: 'World',
	length: 2,
};

// Array.from принимает объект, проверяет, является ли он
// итерируемым объектом или псевдомассивом, затем
// создает новый массив и копирует туда все элементы
let arr = Array.from(arrayLike);

alert(arr.pop()); // World (метод действительно работает)
```
Полный синтаксис `Array.from` позволяет указать необязательную «трансформирующую» функцию:
```js
Array.from(obj[, mapFn, thisArg])
```
Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а `thisArg` позволяет установить `this` для этой функции.

Пример - возводим каждое число в квадрат:
```js
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```

**Небольшие заметки:**
- `for...of` используется исключительно для итерируемых объектов, которые реализуют протокол итератора. То есть цикл будет смотреть на итератор объекта и заниматься итерацией по правилам итератора. Итераторы могут быть разными: например у Array, Set и Map свои собственные итераторы. 
- Можно реализовать собственный итератор для своих объектов и цикл `for...of` будет играть по правилам вашего итератора.
