См. также [[Map и Set]]
Массивы предоставляют множество методов. Так что разобьем на группы.

**Добавление удаление элементов**

-   `arr.push(...items)` – добавляет элементы в конец,
-   `arr.pop()` – извлекает элемент из конца,
-   `arr.shift()` – извлекает элемент из начала,
-   `arr.unshift(...items)` – добавляет элементы в начало.

Другие методы, которые делают то же самое. В этом и других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчет элементов с конца.

**splice**

Это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.

Его синтаксис:
```js
arr.splice(index [, deleteCount, elem1, ..., elemN])
```
Он начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. **Возвращает массив из удалённых элементов.**
Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`:
```js
let arr = ["Я", "изучаю", "JavaScript"];

arr.splice(2, 0, "сложный", "язык");

alert(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

**slice**

Его синтаксис:
```js
arr.slice([start], [end])
```
Он возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end` (не включая `end`). Оба индекса `start` и `end` могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
```js
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
```
Можно вызвать `slice` и вообще без аргументов: `arr.slice()` создаёт копию массива `arr`. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.

**concat**

Этот метод создает новый массив, в который копирует данные из других массивов и дополнительные значения.

Его синтаксис:
```js
arr.concat(arg1, arg2...)
```
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

В результате мы получаем новый массив, включающий в себя элементы из `arr`, а также `arg1`, `arg2` и так далее…

Если аргумент `argN` – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
```js
let arr = [1, 2];

let arrayLike = {
	0: "что-то",
	length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```
…Но если объект имеет специальное свойство `Symbol.isConcatSpreadable`, то он обрабатывается `concat` как массив: вместо него добавляются его числовые свойства.

Для корректной обработки в объекте должны быть числовые свойства и `length`:
```js
let arr = [1, 2];

let arrayLike = {
	0: "что-то",
	1: 'ещё',
	[Symbol.isConcatSpreadable]: true,
	length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

**Перебор: forEach**

Этот метод позволяет запускать функцию для каждого элемента массива.

Его синтаксис:
```js
arr.forEach(function(item, index, array) {
	// ... делать что-то с item
});
```
Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.

**Поиск в массиве**

**indexOf/lastIndexOf и includes**
Эти методы имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:
-   `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на котором был найден искомый элемент, в противном случае `-1`.
-   `arr.lastIndexOf(item, from)` – то же самое, но ищет справа налево.
-   `arr.includes(item, from)` – ищет `item`, начиная с индекса `from`, и возвращает `true`, если поиск успешен

Например:
```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```
Обратите внимание, что методы используют строгое сравнение `===`. Таким образом, если мы ищем `false`, он находит именно `false`, а не ноль.

Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является `arr.includes`.

Кроме того, очень незначительным отличием `includes` является то, что он правильно обрабатывает `NaN` в отличие от `indexOf/lastIndexOf`.

**find и findIndex**

Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?

Здесь пригодится метод `find`.

Его синтаксис таков:
```js
let result = arr.find(function(item, index, array){
	// если true - возвращается текущий item и перебор прерывается
	// если все итерации оказались ложными, возвращается undefined
});
```
Функция вызывается по очереди для каждого элемента массива:

-   `item` – очередной элемент.
-   `index` – его индекс.
-   `array` – сам массив.

Например, у нас есть массив пользователей, каждый из которых имеет поля `id` и `name`. Попробуем найти того, кто с `id == 1`:
```js
let users = [ 
	{id: 1, name: "Вася"}, 
	{id: 2, name: "Петя"},
	{id: 3, name: "Маша"} 
];

let user = arr.find(item => item.id == 1);

alert(user.name); // Вася
```

В реальной жизни массивы объектов – обычное дело, поэтому метод `find` крайне полезен.

Обратите внимание, что в данном примере мы передаём `find` функцию `item => item.id == 1`, с одним аргументом. Это типично, дополнительные аргументы этой функции используются редко.

Метод `findIndex` – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и `-1`, если ничего не найдено.

**filter**

Метод `find` ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт `true`.

На тот случай, если найденных элементов может быть много, предусмотрен метод `arr.filter(fn)`
Синтаксис этого метода схож с `find`, но `filter` возвращает массив из всех подходящих элементов:

```js
let results = arr.filter(function(item, index, array) {
	// если true - элемент добавляется к результату, и перебор продолжается
	// возвращается пустой массив в случае, если ничего не найдено
});
```

**Преобразование массива**

**map**

Данный метод является одним из наиболее полезных и часто используемых.

Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

Синтаксис:
```js
let result = arr.map(function(item, index, array) {
	// возвращается новое значение вместо элемента
});
```

**sort**

Вызов данного метода отсортирует массив *на месте*, меняя в нем порядок элементов.
Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
Например:
```js
let arr = [ 1, 2, 15 ];

// метод сортирует содержимое arr
arr.sort();

alert( arr );  // 1, 15, 2
```
Порядок стал `1, 15, 2`. Это неправильно! Но почему?

**По умолчанию элементы сортируются как строки.**

Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что `"2" > "15"`.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента `arr.sort()`.

Функция должна для пары значений возвращать:
```js
function compare (a,b) {
	if(a > b) return 1;  // если первое значение больше второго
	if(a == b) return 0; // если равны
	if(a < b) return -1; // если первое значение меньше второго
}
```
Теперь всё работает как надо.

Давайте возьмём паузу и подумаем, что же происходит. Упомянутый ранее массив `arr` может быть массивом чего угодно, верно? Он может содержать числа, строки, объекты или что-то ещё. У нас есть набор _каких-то элементов_. Чтобы отсортировать его, нам нужна _функция, определяющая порядок_, которая знает, как сравнивать его элементы. По умолчанию элементы сортируются как строки.

Метод `arr.sort(fn)` реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная [быстрая сортировка](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить `fn`, которая делает это сравнение.

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:
```js
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
	alert( a + " <> " + b );
});
```
В процессе работы алгоритм может сравнивать элемент с другими по нескольку раз, но он старается сделать как можно меньше сравнений.

*Функция сравнения может вернуть любое значение!*
На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

Это позволяет писать более короткие функции:
```js
let arr = [ 1, 2, 15 ];

arr.sort((a,b) => a - b );

alert(arr); // 1,2,15
```

**reverse**

Этот методы меняет порядок элементов в arr на обратный. Он также возвращает массив `arr` с изменённым порядком элементов.
```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

**split и join**
Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, кому его отправить, через запятую: `Вася, Петя, Маша`. Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?

Метод `arr.split(delim)` именно это и делает. Он разбивает строку на массив по заданному разделителю `delim`.
У метода `split` есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:

*Разбивка по буквам*
Вызов `split(s)` с пустым аргументом `s` разбил бы строку на массив букв:
```js
let str = "тест";

alert( str.split('') ); // т,е,с,т
```

Вызов `arr.join(glue)` делает в точности противоположное `split`. Он создаёт строку из элементов `arr`, вставляя `glue` между ними.

Например:
```js
let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша
```

**reduce/ reduceRight**

Если нам нужно перебрать массив – мы можем использовать `forEach`, `for` или `for..of`.

Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем `map`.

Методы `arr.reduce` и `arr.reduceRight` похожи на методы выше, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.

Синтаксис:
```js
let value = arr.reduce(function(previousValue, item, index, array) {
	// ...
}, [initial]);
```
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

-   `previousValue` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
-   `item` – очередной элемент массива,
-   `index` – его индекс,
-   `array` – сам массив.

При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом `reduce`.

Мы также можем опустить начальное значение. Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Этот метод проще всего понять на примере. Тут мы получим сумму всех элементов массива всего одной строкой:
```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0)

alert(result); // 15
```
Здесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.

Давайте детальнее разберём, как он работает.

1.  При первом запуске `sum` равен `initial` (последний аргумент `reduce`), то есть `0`, а `current` – первый элемент массива, равный `1`. Таким образом, результат функции равен `1`.
2.  При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).
3.  При третьем запуске `sum = 3`, к которому мы добавляем следующий элемент, и так далее…

Метод `arr.reduceRight` работает аналогично, но проходит по массиву справа налево.

**Большинство методов поддерживают "thisArg"**

Почти все методы массива, которые вызывают функции – такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.

Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:
```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент!
```