В нашем арсенале **структур для хранения данных** имеется:
- Объект - для хранения именованных коллекций.
- Массив - для хранения упорядоченных коллекций.


Расширяем наш боевой комплект двумя новыми структурами данных: **Map** и **Set**.

**Map**

[Map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map) – это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.
Методы и свойства:
- `new Map()` - создание коллекции.
- `map.set(key, value)` - записывает по ключе key значение value.
- `map.get(key)` - возвращает значение по ключу или `undefined`, если ключ key отсутствует.
- `map.has(key)` - возвращает true, если ключ присутствует в коллекции, иначе false.
- `map.delete(key)` - удаляет элемент по ключу key.
- `map.clear()` - очищает коллекцию от всех элементов.
- `map.size` - возвращает текущее количество элементов.

Например:
```js
let map = new Map();

map.set('1','str1');
map.set(1, 'num1');
map.set(true, 'bool1');

// Обычный объект приводит ключи к строкам!!!

alert(map.get(1));   // 'num1'
alert(map.get('1')); // 'str1'

alert(map.size); // 3
```
**Map может использовать объекты в качестве ключей.**
Но как же объект Map сравнивает ключи? Он использует алгоритм [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). Почти аналогично сравнению, что и `===`, с той лишь разницей, что NaN считается равным `NaN`. Так что и `NaN` также может использоваться в качестве ключа.
Этот алгоритм не может быть заменён или модифицирован.

**Цепочка вызовов**
Каждый вызов `map.set` возвращает объект map, так что можем объединить вызовы в цепочку:
```js
map.set('1','str1')
	.set(1,'num1')
	.set(true, 'bool1');
```

**Перебор Map**
Для перебора коллекции Map есть 3 метода:
- map.keys() - возвращает итерируемый объект по ключам.
- map.values() - возвращает итерируемый объект по значениям.
- map.entries() - возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в `for...of`.

Например: 
```js
let recipeMap = new Map([
	['огурец', 500],
	['помидор', 350],
	['лук', 50],
]);

// Перебор по ключам
for (let vegetable of recipeMap.keys()) {
	alert(vegetable); // огурец, помидор, лук
}

// Перебор по значениям
for (let amount of recipeMap.values()) {
	alert(amount); // 500, 350, 50
}

//Перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // Аналогично recipeMap.entries()
	alert(entry); //огурец, 500 (и так далее)
}
```
Стоит помнить, что в отличие от обычных объектов в `Object`, в `Map` перебор происходит в том же порядке, в каком происходило добавление элементов.
Кроме этого, `Map` имеет встроенный метод `forEach`, схожий со встроенным методом массивов (cм. также [[Методы массивов]]) `Array`:
```js
recipeMap.forEach((value,key,map) => {
	alert(`${key}: ${value}`); // огурец: 500 (и т.д)
});
```

**Object.entries: Map из Object**
Если у нас уже есть некий объект (в котором пары ключ-значение), и мы захотели сделать из него `Map`, то для этого есть встроенный метод `Object.entries(obj)`, который получает объект и возвращает массив пар ключ-значение.
Приступим:
```js
let obj = {
	name: 'John',
	age: 30
};

let map = new Map(Object.entries(obj));
```
Здесь `Object.entries` возвращает массив пар ключ-значение: `[ ["name","John"], ["age", 30] ]`. Это именно то, что нужно для создания `Map`.

**Object.fromEntries: Object из Map**
Мы только что видели, как создать `Map` из обычного объекта при помощи `Object.entries(obj)`.
Есть метод `Object.fromEntries`, который делает противоположное: получив массив пар вида `[ключ, значение]`, он создаёт из них объект:

Мы можем использовать `Object.fromEntries`, чтобы получить обычный объект из `Map`.
К примеру, у нас данные в `Map`, но их нужно передать в сторонний код, который ожидает обычный объект.

Вот как это сделать:
```js
let map = new Map();
map.set('banana',1);
map.set('orange',2);
map.set('meat',4);

let obj = Object.fromEntries(map.entries());

// Все получилось!
// obj = { banana: 1, orange: 2, meat: 4 }
```
Вызов `map.entries()` возвращает итерируемый объект пар ключ/значение, как раз в нужном формате для `Object.fromEntries`.
Мы могли бы сократить строчку с созданием объекта:
```js
let obj = Object.fromEntries(map);
```
Это то же самое, так как `Object.fromEntries` ожидает перебираемый объект в качестве аргумента, не обязательно массив. А перебор `map` как раз возвращает пары ключ/значение, так же, как и `map.entries()`. Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в `map`.

**Set**

Объект Set - это особый вид коллекции: "множество" значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
-   `new Set(iterable)` – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
-   `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
-   `set.delete(value)` – удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
-   `set.has(value)` – возвращает `true`, если значение присутствует в множестве, иначе `false`.
-   `set.clear()` – удаляет все имеющиеся значения.
-   `set.size` – возвращает количество элементов в множестве.
Основная «изюминка» – это то, что при повторных вызовах `set.add()` с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.
Альтернативой множеству `Set` может выступать массив для хранения гостей и дополнительный код для проверки уже имеющегося элемента с помощью [arr.find](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find). Но в этом случае будет хуже производительность, потому что `arr.find` проходит весь массив для проверки наличия элемента. Множество `Set` лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность.

**Перебор объекта Set**
Мы можем перебрать содержимое объекта set как с помощью метода `for..of`, так и используя `forEach`:
```js
let set = new Set(['машина','осьминог', 'дедушка']);

for (let value of set) alert(value);

// Аналогично, но только с forEach:
set.forEach((value, valueAgain, set) => {
	alert(value);
})
```
Заметим забавную вещь. Функция в `forEach` у `Set` имеет 3 аргумента: значение `value`, потом _снова то же самое значение_ `valueAgain`, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом `Map`, в котором колбэк `forEach` имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить `Map` на `Set` и наоборот.
`Set` имеет те же встроенные методы, что и `Map`:
-   `set.values()` – возвращает перебираемый объект для значений,
-   `set.keys()` – то же самое, что и `set.values()`, присутствует для обратной совместимости с `Map`,
-   `set.entries()` – возвращает перебираемый объект для пар вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.

См. также:
[[Перебираемые объекты]]
