**Объявление реактивного состояния**

Чтобы создать реактивное состояние из объекта JavaScript, нужно использовать метод `reactive`: 

```js
import { reactive } from 'vue'

// реактивное состояние
const state = reactive({
  count: 0
})
```

Возвращаемое состояние здесь будет являться реактивным объектом. Реактивное преобразование "глубокое" - оно будет влиять вообще на все вложенные свойства переданного объекта.

Основной сценарий использования реактивного состояния во Vue - это использование во время отрисовки. Благодаря тому, что мы отслеживаем зависимости, представление будет обновляться автоматические при изменениях реактивного состояния. 

**Создание автономных ссылок на реактивные значения**

Чтобы сделать примитивные значения реактивными, используется функция `ref`:

```js
import { ref } from 'vue'

const count = ref(0)
```

`ref` вернёт реактивный объект, который можно изменять и который служит реактивной ссылкой для внутреннего значения, которон он хранит - откуда и происходит его имя. Этот объект содержит только одно свойство - `value`.

```js
import { ref } from 'vue'

const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

**Разворачивание ref-ссылок**

Когда ref-ссылка возвращается в качестве свойства для контекста отрисовки (объект, возвращаемый из `setup()`) и доступ к свойству осуществляется в шаблоне, то ссылка автоматически разворачивается во внутреннее значение.

Так что в шаблоне мы не обращаемся через `.value`. Это нужно, если мы используем вложенные ref-ссылки:

```vue
<template>
  <div>
    <span>{{ count }}</span>
    <button @click="count ++">Увеличить счётчик</button>
    <button @click="nested.count.value ++">Увеличить вложенный счётчик</button>
  </div>
</template>

<script>
  import { ref } from 'vue'
  export default {
    setup() {
      const count = ref(0)
      return {
        count,

        nested: {
          count
        }
      }
    }
  }
</script>
```

Совет! Если обращаться к реальному экземпляру объекта не потребуется, то можно обернуть его в метод `reactive`: 

```js
nested: reactive({
  count
})
```

**Доступ в реактивных объектах**

При доступе к `ref` или мутировании как свойства реактивного объекта, автоматически она будет разворачиваться во внутреннее значение и вести себя как обычное свойство:

```js
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

Если новая ссылка присваивается к свойству, связанному с существующей ссылкой, то она просто заменит собой старую ссылку:

```js
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
console.log(count.value) // 1
```

Разворачивание ссылки происходит лишь в том случае, если она вложена в реактивный `Object`. Никакого разворачивания выполняться не будет, когда ссылка предоставляет доступ к `Array` или нативной коллекции, например `Map`:

```js
const books = reactive([ref('Руководство по Vue 3')])
// потребуется указывать .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// потребуется указывать .value
console.log(map.get('count').value)
```

**Деструктурирование реактивного состояния**

При необходимости использовать лишь несколько свойств из большого реактивного объекта, может возникнуть соблазн воспользоваться *деструктурированием из ES6* для получения нужных свойств:

```js
import { reactive } from 'vue'

const book = reactive({
  author: 'Команда Vue',
  year: '2021',
  title: 'Руководство Vue 3',
  description: 'Вы его читаете прямо сейчас ;)',
  price: 'free'
})

let { author, title } = book
```

К сожалению, *при таком деструктурироании реактивность обоих свойст будет потеряна*. Для таких случаев необходимо сначала преобразовать реактивный объект в набор ссылок. Эти ссылки сохранят реактивную связь с исходным объектом:

```js
import { reactive, toRefs } from 'vue'

const book = reactive({
  author: 'Команда Vue',
  year: '2021',
  title: 'Руководство Vue 3',
  description: 'Вы его читаете прямо сейчас ;)',
  price: 'free'
})

let { author, title } = toRefs(book)

title.value = 'Детальное руководство по Vue 3' // нужно .value потому что title теперь ссылка
console.log(book.title) // 'Детальное руководство по Vue 3'
```

**Предотвращение изменений реактивных объектов с помощью `readonly`**

Иногда необходимо отслеживать изменения реактивного объекта (`ref` или `reactive`), но при этом запретить его изменения из определённого места приложения. Например, когда используем реактивный объект,внедряемый через `provide`, и хотим предотвратить попытки изменений там, где он будет внедряться. Для таких случаев можно создать прокси «только для чтения» исходного объекта:

```js
import { reactive, readonly } from 'vue'

const original = reactive({ count: 0 })

const copy = readonly(original)

// изменение оригинала будет вызывать наблюдатели, которые отслеживают копию
original.count++

// изменение копии не пройдёт и будет отображено предупреждение
copy.count++ // warning: "Set operation on key 'count' failed: target is readonly."
```