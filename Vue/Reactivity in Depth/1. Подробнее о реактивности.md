Модели во Vue представляют собой проксированные JavaScript-объекты. По мере их изменения обновляется и представление данных. Выглядит удобно и просто, но есть моменты, которые нужно осознавать и понимать, чтобы избежать распространённых ошибок.

Так что стоит рассмотреть подробнее детали низкоуровненой реализации системы реактивности Vue.

**Что такое реактивность?**

Реактивность - концепция, которая позволяет приспосабливаться к изменениям декларативным способом. Типичный пример - электронная таблица Excel. 

Правда, в JavaScript так не работает :)

```js
let val1 = 2
let val2 = 3
let sum = val1 + val2

console.log(sum) // 5

val1 = 3

console.log(sum) // по-прежнему 5
```

Мы меняем первое число - сумма не пересчитывается. 
Как же превратить код на JavaScript в самодельную таблицу Excel?

Говоря в общем, нужно сделать несколько вещей:
1. *Отслеживать, когда значение считывается*. Например, для выражения `val1 + val2` будет считываться значение `val1` и `val2`.
2. *Определять, когда значение изменится*. Например, при присвоении `val1 = 3`.
3. *Перезапускать код, который считывал значения изначально*. Например, снова выполнить `sum = val1 + val2` для обновления значения `sum`.

Код выше не адаптирован к такому, так что вернемся к нему позже, чтобы можно было адаптировать его для совместимости с системой реактивности Vue.

**Как Vue определяет, какой код выполнялся**

Чтобы пересчитывать сумму всякий раз, когда меняется какое-либо число, нужно обернуть её в функцию:

```js
const updateSum = () => {
  sum = val1 + val2
}
```

Но Vue должен знать об этой функции!

Так вот Vue с помощью *эффекта* отслеживает, какая функция в данный момент была запущена. *Эффект* - обёртка вокруг функции, которая начинается отслеживание непосредственно перед её вызовом. 

Попробуем реализовать сами, чтобы понять, как Vue примерно работает.


Для начала требуется что-то, что может обернуть вычисление суммы вот так:

```js
createEffect(() => {
  sum = val1 + val2
})
```

Для этого требуется создать `createEffect`, чтобы отслеживать выполнение функции вычисления суммы. Реализовать подобное можно примерно так:

```js
// Стек для хранения запущенных эффектов
const runningEffects = []

const createEffect = fn => {
  // Оборачиваем переданную fn в функцию эффекта
  const effect = () => {
    runningEffects.push(effect)
    fn()
    runningEffects.pop()
  }

  // Автоматически сразу запускаем эффект
  effect()
}
```

Запуск эффекта будет добавлять его в массив `runningEffects` перед вызовом `fn`. Теперь, если потребуется узнать какой эффект запущен в данный момент, достаточно проверить этот массив.

Эффекты выступают в качестве стартовой точки для многих возможностей. Например, как отрисовка компонента, так и вычисляемые свойства внутри используют эффекты. Каждый раз, когда что-то «волшебным» образом реагирует на изменение данных, можно быть уверенным что это было обёрнуто в эффект.

Несмотря на то, что публичный API Vue не позволяет создавать эффекты напрямую, он предоставляет доступ к функции `watchEffect`, которая ведёт себя очень похоже на `createEffect` из примера выше.

Но понимание какой код выполняется - лишь одна из частей головломки. Как же Vue узнает, какие значения использует эффект и как определяет, что они изменились? 

**Как Vue отслеживает изменения?**

Отследить переназначение локальных переменных никак не получится, в JavaScript просто нет такого механизма. 

Но можно отследить изменения в объектах! 

Тут на помощь приходит Proxy из ES6, который позволил переписать реактивность в Vue 3 и избавиться от проблем в предыдущих версиях Vue.

Vue оборачивает объект в Proxy с обработчиками `get` и `set`.

*Proxy - это объект, который содержит в себе другой объект или функцию и позволяет "перехватывать" их*.

Использование прокси на примере: `new Proxy(target, handler)`

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property) {
    console.log('перехвачен!')
    return target[property]
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// перехвачен!
// tacos
```

Как мы можем заметить, мы можем реализовать почти все, что угодно, в наших геттерах и сеттерах! Это делает Proxy нереально мощным инструментом.

При использовании Proxy есть одна сложность — привязка к `this`. Хочется, чтобы любой метод был привязан к Proxy, а не к отслеживаемому объекту, чтобы была возможность перехватывать и их тоже. К счастью, ES6 предоставляет ещё одну возможность, названную `Reflect`, которая позволяет избежать этой проблемы с минимальными усилиями:

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property, receiver) {
    return Reflect.get(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Первым шагом к реализации реактивности с Proxy будет отслеживание считывания свойства. Сделаем это в обработчике, в функции с названием `track`, в которую передаётся `target` и `property`:

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property, receiver) {
    track(target, property)
    return Reflect.get(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Реализация метода `track` здесь не показана. Она проверяет, какой _эффект_ в данный момент запущен, и записывает его вместе с `target` и `property`. Таким образом Vue определяет, что свойство является зависимостью эффекта.

Наконец, необходимо повторно запустить эффект при изменении значения свойства. Для этого воспользуемся обработчиком `set` в прокси:

```js
const dinner = {
  meal: 'tacos'
}

const handler = {
  get(target, property, receiver) {
    track(target, property)
    return Reflect.get(...arguments)
  },
  set(target, property, value, receiver) {
    trigger(target, property)
    return Reflect.set(...arguments)
  }
}

const proxy = new Proxy(dinner, handler)
console.log(proxy.meal)

// tacos
```

Помните этот список? Теперь уже есть некоторые ответы, как во Vue реализуются эти шаги:

1.  *Отслеживать когда значение считывается*: функция `track` в обработчике `get` прокси записывает свойство и текущий эффект.
2.  *Определять когда значение изменяется*: в прокси вызывается обработчик `set`.
3.  *Перезапускать код, который считывал значения изначально*: функция `trigger` ищет какие эффекты зависят от изменившегося свойства и запускает их.

И так, вернёмся к самому первому примеру и реализуем его на Vue:

```js
const vm = createApp({
  data() {
    return {
      val1: 2,
      val2: 3
    }
  },
  computed: {
    sum() {
      return this.val1 + this.val2
    }
  }
}).mount('#app')

console.log(vm.sum) // 5

vm.val1 = 3

console.log(vm.sum) // 6
```

Объект, возвращаемый из `data`, будет обёрнут в реактивный прокси и сохранён как `this.$data`. Свойства `this.val1` и `this.val2` будут псевдонимами для `this.$data.val1` и `this.$data.val2` соответственно, поэтому они проходят через один и тот же прокси.

Vue обернёт функцию для `sum` в эффект. При попытке чтения `this.sum`, он запустит этот эффект для вычисления значения. Реактивный прокси вокруг `$data` позволит отследить, что свойства `val1` и `val2` были прочитаны во время выполнения этого эффекта.

Начиная с Vue 3, реактивность доступна как отдельный пакет. Функция, которая оборачивает `$data` в прокси называется `reactive`. Её можно вызвать напрямую, если нужно обернуть объект в реактивный проекси без необходимости использовать компонент:

```js
const proxy = reactive({
  val1: 2,
  val2: 3
})
```

**Проксированные объекты**

Под капотом Vue отслеживает все объекты, которые были сделаны реактивными, поэтому для каждого объекта всегда возвращается свой Proxy.

Когда требуется доступ к вложенному объекту внутри реактивной Proxy, этот объект перед возвращением _также преобразуется_ в Proxy.

```js
const handler = {
  get(target, property, receiver) {
    track(target, property)
    const value = Reflect.get(...arguments)
    if (isObject(value)) {
      // Оборачиваем вложенный объект в собственный реактивный прокси
      return reactive(value)
    } else {
      return value
    }
  }
  // ...
}
```

**Proxy vs оригинальная сущность**

При использовании Proxy нужно запомнить — проксируемый объект *не будет равен* оригинальному объекту в строгих сравнениях (`===`). Например:

```js
const obj = {}
const wrapped = new Proxy(obj, handlers)

console.log(obj === wrapped) // false
```

Хорошей практикой будет никогда не сохранять ссылку на оригинальный объект и работать только с реактивной версией.

```js
const obj = reactive({
  count: 0
}) // никакой ссылки на оригинал
```

Vue не оборачивает в Proxy примитивные значения (числа, строки), поэтому `===` можно использовать напрямую с такими значениями:

```js
const obj = reactive({
  count: 0
})

console.log(obj.count === 0) // true
```

**Как отрисовка реагирует на изменения**

Шаблон компонента компилируется в `render`-функцию. Функция `render` создаёт дерево из VNode, которое описывает как компонент должен быть отрисован. Она также обёрнута в эффект, что позволяет Vue отслеживать свойства, которые считываются во время работы. 

Функция `render` концептуально очень похожа на свойство `computed`. Vue не отслеживает каким именно образом зависимости используются, он только знает, что они использовались в какой-то момент во время работы функции. Если какое-либо из этих свойств изменится впоследствии, то это вызовет повторный запуск эффекта и перезапуск функции `render` для генерации нового дерева из VNode. После чего оно будет использовано для внесения необходимых изменений в DOM.