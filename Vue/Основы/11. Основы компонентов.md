Компоненты — переиспользуемые экземпляры со своим именем. Поскольку компоненты это переиспользуемые экземпляры, то у них могут быть те же опции что и у корневого экземпляра: `data`, `computed`, `watch`, `methods`, хуки жизненного цикла.

**Переиспользование компонентов**

Компоненты можно повторно использовать столько раз, сколько потребуется:

```html
<div id="components-demo">
  <button-counter></button-counter>
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>
```

Обратите внимание, при нажатиях на кнопки, каждая изменяет свой собственный `count`. Всё потому, что каждый раз при использовании компонента будет создаваться его **новый экземпляр**.

**Организация компонентов**

Обычно приложение организуется в виде дерева вложенных компонентов. Например, может быть компонент для заголовка, боковой панели, зоны контента, каждый из которых содержит другие компоненты для навигационных ссылок, постов блога и т.д.

Чтобы использовать компоненты в шаблонах, сначала их нужно зарегистрировать, чтобы Vue узнал о них. Есть два типа регистрации компонентов: **глобальная** и **локальная**. Ранее компоненты регистрировались только глобально, используя метод приложения `component`:

```js
const app = Vue.createApp({})

app.component('my-component-name', {
  // ... опции ...
})
```

Пока это база, которой хватит знать.

**Передача данных в дочерние компоненты через входные параметры**

Ранее создавался компонент для записи блога. Но проблема в том, что этот компонент бесполезен, если не будет возможности передавать ему данные, такие как заголовок и содержимое записи блога, которую нужно показать. Для этого и нужны входные параметры.

Входные параметры — пользовательские атрибуты, которые указываются на компоненте. Чтобы передавать заголовок в компонент записи блога, нужно определить его в списке входных параметров, которые принимает компонент, с помощью опции `props`:

```js
const app = Vue.createApp({})

app.component('blog-post', {
  props: ['title'],
  template: `<h4>{{ title }}</h4>`
})

app.mount('#blog-post-demo')
```

При передаче значения в атрибут входного параметра, оно станет свойством данного экземпляра. Значение этого свойства доступно в шаблоне, как и любое другое свойство компонента.

Компонент может принимать столько входных параметров, сколько потребуется, и по умолчанию любое значение может передаваться в любой входной параметр.

После объявления входного параметра можно передавать данные в него через пользовательский атрибут, например:

```html
<div id="blog-post-demo" class="demo">
  <blog-post title="My journey with Vue"></blog-post>
  <blog-post title="Blogging with Vue"></blog-post>
  <blog-post title="Why Vue is so fun"></blog-post>
</div>
```

**Прослушивание событий из дочерних компонентов в родительских компонентах**

При доработках компонента `<blog-post>` некоторым возможностям может потребоваться передавать данные обратно в родительский компонент. Например, позволить увеличивать размер текста записей блога для улучшения доступности, оставляя остальную часть страницы с размером текста по умолчанию.

Для этого добавим свойство `postFontSize` в родительском компоненте:

```js
const App = {
  data() {
    return {
      posts: [
        /* ... */
      ],
      postFontSize: 1
    }
  }
}
```

И воспользуемся им в шаблоне чтобы установить размер шрифта для всех записей блога:

```html
<div id="blog-posts-events-demo">
  <div :style="{ fontSize: postFontSize + 'em' }">
    <blog-post
      v-for="post in posts"
      :key="post.id"
      :title="post.title"
    ></blog-post>
  </div>
</div>
```

Теперь перед содержимым каждой записи блога добавим кнопку для увеличения текста:

```html
app.component('blog-post', {
  props: ['title'],
  template: `
    <div class="blog-post">
      <h4>{{ title }}</h4>
      <button>
        Увеличить размер текста
      </button>
    </div>
  `
})
```

Проблема пока в том, что эта кнопка ничего не делает:

```html
<button>
  Увеличить размер текста
</button>
```

При нажатии на кнопку нужно каким-то образом сообщать родительскому компоненту, что требуется увеличить размер текста для всех записей блога. Для решения этой проблемы, экземпляры компонента предоставляют собственную систему событий. Родительский компонент может прослушивать любые события на экземпляре дочернего компонента с помощью `v-on` или `@`, аналогично отслеживанию нативных событий DOM:

```html
<blog-post ... @enlarge-text="postFontSize += 0.1"></blog-post>
```

А чтобы сгенерировать событие, дочерний компонент может воспользоваться встроенным [методом **`$emit`**](https://v3.ru.vuejs.org/ru/api/instance-methods.html#emit), передавая в него аргументом имя события:

```html
<button @click="$emit('enlargeText')">
  Увеличить размер текста
</button>
```

Благодаря прослушиванию события `@enlarge-text="postFontSize += 0.1"` в родительском компоненте, получится отследить его и обновить `postFontSize` новым значением.

Все генерируемые компонентом события можно указать в опции `emits`:

```js
app.component('blog-post', {
  props: ['title'],
  emits: ['enlargeText']
})
```

Это позволит проверять все события, генерируемые компонентом, и при необходимости [валидировать их](https://v3.ru.vuejs.org/ru/guide/component-custom-events.html#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8).

**Передача данных вместе с событием**

Иногда полезнее вместе с событием отправить какие-либо данные. Например, если решим, что компонент `<blog-post>` будет отвечать за то, насколько следует увеличить текст. Тогда для передачи этого значения можно использовать второй параметр `$emit`:

```html
<button @click="$emit('enlargeText', 0.1)">
  Увеличить размер текста
</button>
```

Теперь, при прослушивании события в родительском компоненте, доступ к этому значению можно будет получить через специальную переменную `$event`:

```html
<blog-post ... @enlarge-text="postFontSize += $event"></blog-post>
```

А если обработчик события будет указан именем метода:

```
<blog-post ... @enlarge-text="onEnlargeText"></blog-post>
```

То это значение будет передано в него первым аргументом:

```js
methods: {
  onEnlargeText(enlargeAmount) {
    this.postFontSize += enlargeAmount
  }
}
```

**Использование v-model на компонентах**

Пользовательские события также могут использоваться для создания нестандартных элементов ввода, которые будут работать вместе с `v-model`. Не забывайте, что:

```html
<input v-model="searchText" />
```

выполняет то же самое, что и:

```html
<input :value="searchText" @input="searchText = $event.target.value" />
```

Использование `v-model` на компоненте будет выполнять следующее:

```html
<custom-input
  :model-value="searchText"
  @update:model-value="searchText = $event"
></custom-input>
```

Однако для того, чтобы это всё заработало, `<input>` внутри компонента должен:

-   Привязывать к значению атрибута `value` входной параметр `modelValue`
-   При событии `input` генерировать событие `update:modelValue` с новым значением

Как получится в итоге:

```html
app.component('custom-input', {
  props: ['modelValue'],
  emits: ['update:modelValue'],
  template: `
    <input
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
    />
  `
})
```

Теперь такой компонент будет прекрасно работать с `v-model`:

```html
<custom-input v-model="searchText"></custom-input>
```

Другим способом реализации `v-model` в компоненте будет использование вычисляемых свойств и их возможностей определить геттер и сеттер. Метод `get` должен возвращать свойство `modelValue`, а метод `set` генерировать соответствующее событие:

```js
app.component('custom-input', {
  props: ['modelValue'],
  emits: ['update:modelValue'],
  template: `
    <input v-model="value">
  `,
  computed: {
    value: {
      get() {
        return this.modelValue
      },
      set(value) {
        this.$emit('update:modelValue', value)
      }
    }
  }
})
```

**Распределение контента слотами**

Как и в случае с обычными HTML-элементами, часто бывает полезным иметь возможность передавать компоненту содержимое, например таким образом:

```html
<alert-box>
  Произошло что-то плохое.
</alert-box>
```

Такого можно добиться при помощи пользовательского элемента `<slot>` у Vue:

```html
app.component('alert-box', {
  template: `
    <div class="demo-alert-box">
      <strong>Ошибка!</strong>
      <slot></slot>
    </div>
  `
})
```

Как можно увидеть выше, слот будет использоваться в качестве места, куда потребуется подставлять контент — и это всё. Готово!

**Динамическое переключение компонентов**

Иногда бывает полезным динамически переключаться между компонентами, как например в интерфейсе с вкладками. 

Это возможно сделать с помощью элемента `<component>` со специальным атрибутом `is`:

```html
<!-- Компонент будет меняться при изменении currentTabComponent -->
<component :is="currentTabComponent"></component>
```

В примере выше значением `currentTabComponent` может быть:

-   имя зарегистрированного компонента, или
-   объект с настройками компонента

Посмотрите [этот sandbox (opens new window)](https://codepen.io/team/Vue/pen/oNXaoKy)чтобы поэкспериментировать с полным кодом, или [эту версию (opens new window)](https://codepen.io/team/Vue/pen/oNXapXM)с примером привязки объекта с настройками компонента вместо указания его имени.

Можно также использовать атрибут `is` и для создания обычных HTML-элементов.

**Отсутствие чувствительности к регистру**

```js
// camelCase в JavaScript
app.component('blog-post', {
  props: ['postTitle'],
  template: `
    <h3>{{ postTitle }}</h3>
  `
})
```

```html
<!-- kebab-case в HTML -->
<blog-post post-title="hello!"></blog-post>
```