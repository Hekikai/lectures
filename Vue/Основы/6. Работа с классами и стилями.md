Нам всем никогда не хочется писать инлайн стили (если только это не какое-то одно свойство, которое потом точно не поменяется). Сразу в голову приходит идея использовать директиву `v-bind`, но и тут  Vue предоставляет нам наиболее удобное решение: улучшение `v-bind` при работе с `class`и `style`. Кроме строк, выражения могут принимать массивы или объекты.

**Связывание CSS-классов**

*Объектный синтаксис*

Для динамической установки или удаления CSS-классов в директиву `:class` (сокращение для `v-bind:class`) можно передавать объект:

```html
<div :class="{ active: isActive }"></div>
```

Синтаксис выше означает, что наличие класса `active` на элементе будет определяться [истинностью (opens new window)](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)значения свойства `isActive`.

Подобным образом можно управлять несколькими классами, добавляя в объект и другие поля. Кроме того, `:class` можно использовать совместно с обычным атрибутом `class`:

```html
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
>
</div>
```

Если данные будут такими:

```js
data() {
  return {
    isActive: true,
    hasError: false
  }
}
```

То результат будет таким:

```html
<div class="static active"></div>
```

Классы будут обновлены при изменениях `isActive` или `hasError`. Например, `hasError` изменится в `true` и значение атрибута `class` станет `"static active text-danger"`.

Сам же объект со стилями необязательно указывать инлайн прямо в шаблоне:

```html
<div :class="classObject"></div>
```

```js
data() {
  return {
    classObject: {
      active: true,
      'text-danger': false
    }
  }
}
```

Результат будет таким же. Также можно использовать [вычисляемые свойства](https://v3.ru.vuejs.org/ru/guide/computed.html), которые будут возвращать итоговый объект — очень распространённый и мощный приём:

```html
<div :class="classObject"></div>
```

```js
data() {
  return {
    isActive: true,
    error: null
  }
},
computed: {
  classObject() {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

*Синтаксис с массивом*

Можно передать массив в `:class`, чтобы применить список классов:

```html
<div :class="[activeClass, errorClass]"></div>
```

```js
data() {
  return {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
}
```

Переключать классы в массиве, в зависимости от некоторого условия, можно с помощью условного оператора в форме тернарного выражения:

```html
<div :class="[isActive ? activeClass : '', errorClass]"></div>
```

К элементу будет всегда добавляться `errorClass`, но `activeClass` — только в случае истинности `isActive`.

Однако, такая запись начинает выглядеть слегка громоздко, особенно если есть несколько классов, задаваемых по условию. Поэтому возможно использовать и смешанный синтаксис:

```html
<div :class="[{ active: isActive }, errorClass]"></div>
```

*Использованеи с компонентами*

Если мы используем атрибут `class` на пользовательском компоненте с одним корневым элементом, то все эти классы будут добавлены к корневому элементу!

Например:

```js
const app = Vue.createApp({})

app.component('my-component', {
  template: '<p class="foo bar">Привет</p>'
})
```

Если добавить несколько классов на компонент:

```html
<div id="app">
  <my-component class="baz boo"></my-component>
</div>
```

То в результате отрисовки получим:

```html
<p class="foo bar baz boo">Привет</p>
```

То же самое справедливо для `:class`.

Если у компонента несколько корневых элементов, то потребуется определить какой из них будет получать эти классы. Это реализуется добавлением свойства `$attrs` на элемент:

```html
<div id="app">
  <my-component class="baz"></my-component>
</div>
```

```js
const app = Vue.createApp({})

app.component('my-component', {
  template: `
    <p :class="$attrs.class">Привет!</p>
    <span>Это дочерний компонент</span>
  `
})
```

**Связывание inline-стилей**

*Объектный синтаксис*

Объектный синтаксис для `:style` выглядит почти как для CSS, за исключением того, что это объект JavaScript. Поэтому для указания имён свойств CSS можно использовать как camelCase, так и kebab-case (не забывайте про кавычки при использовании kebab-case):

```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

```js
data() {
  return {
    activeColor: 'red',
    fontSize: 30
  }
}
```

Рекомендуется привязывать стили к объекту данных, чтобы сделать шаблон чище:

```html
<div :style="styleObject"></div>
```

```js
data() {
  return {
    styleObject: {
      color: 'red',
      fontSize: '13px'
    }
  }
}
```

Аналогично можно использовать и вычисляемые свойства, возвращающие объект стилей.

*Синтаксис с массивом*

Синтаксис с массивом для `:style` позволяет применить несколько объектов стилей к одному и тому же элементу:

```html
<div :style="[baseStyles, overridingStyles]"></div>
```

**Автоматические префиксы**

Если использовать CSS-свойство, которое требует [вендорного префикса (opens new window)](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix)в `:style`, Vue автоматически добавит соответствующий префикс. Во время выполнения будет проверять какие стилевые свойства поддерживаются в текущем браузере. Если определённое свойство не поддерживается браузером, то будут проверены различные варианты префиксов, чтобы попытаться найти тот, который поддерживается.

**Множественные значения**

Можно передать массив из нескольких (префиксных) значений в свойство style, например:

```html
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

В этом случае будет выбрано только последнее значение в массиве, которое поддерживает браузер. Например, `display: flex` для браузеров с поддержкой flexbox без префиксов.