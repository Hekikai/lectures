Начинаем пользоваться Composition API в функции `setup()`, которая объявлена внутри экспортируемого (ну или нет?) компонента.

Данная функция получает два аргумента:
1. `props` - входные параметры
2. `context` - контекст

Разберёмся, что есть что.

**Входные параметры (пропсы)**

Как и в обычном компоненте, пропсы внутри функции `setup` реактивны, так что они будут обновляться при передаче новых значений.

```js
// MyBook.vue

export default {
  props: {
    title: String
  },
  setup(props) {
    console.log(props.title)
  }
}
```

Важно! Так как пропсы *реактивны*, то нельзя использовать деструктуризацию ES6, потому что это уберёт реактивность со входных параметров.

Если необходимо выполнить деструктуризацию входных параметров, то это можно сделать с помощью `toRefs` внутри функции `setup`:

```js
// MyBook.vue

import { toRefs } from 'vue'

setup(props) {
  const { title } = toRefs(props)

  console.log(title.value)
}
```

Если, например, `title` необязательный входной параметр, то он может отсутствовать в `props`. В этом случае `toRefs` не создаёт ссылку для `title` и вместо него потребуется воспользоваться `toRef`:

```js
// MyBook.vue

import { toRef } from 'vue'

setup(props) {
  const title = toRef(props, 'title')

  console.log(title.value)
}
```

**Контекст**

`context` - это обычный JavaScript объект, через который доступны все другие значения компонента, которые могут быть полезны внтруи `setup`:

```js
// MyBook.vue

export default {
  setup(props, context) {
    // Атрибуты (нереактивный объект, эквивалент $attrs)
    console.log(context.attrs)

    // Слоты (нереактивный объект, эквивалент $slots)
    console.log(context.slots)

    // Генерация событий (функция, эквивалент $emit)
    console.log(context.emit)

    // Объявленные публичные свойства (функция)
    console.log(context.expose)
  }
}
```

Так как контекст не реактивный, то тут можно спокойно использовать деструктуризацию из ES6:

```js
// MyBook.vue
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
```

Свойства `attrs` и `slots` - объекты с сотоянием, которые всегда будут обновляться при обновлении самого компонента. Так что следует избегать их деструктуризации и всегда ссылаться на свойства как `attrs.x` и `slots.x`.

В отличие от `props`, `attrs` и `slots` - не реактивны. Если необходимо применять побочные эффекты, основанные на изменениях `attrs` и `slots`, то следует делать это внутри хука жизненного цикла `onBeforeUpdate`.

**Доступ к свойствам компонента**

При выполнении `setup` у нас есть доступ только к:
- `props`
- `emit`
- `attrs`
- `slots`

И нет доступа к:
- `data`
- `computed`
- `methods`
- `refs` (ссылки на элементы шаблона)

**Использование в шаблонах**

Возвращая из функции `setup` объект, мы в шаблоне получаем доступ к полям этого объекта!

```vue
<!-- MyBook.vue -->
<template>
  <div>{{ collectionName }}: {{ readersNumber }} {{ book.title }}</div>
</template>

<script>
  import { ref, reactive } from 'vue'

  export default {
    props: {
      collectionName: String
    },
    setup(props) {
      const readersNumber = ref(0)
      const book = reactive({ title: 'Руководство Vue 3' })

      // всё объявленное будет доступно в шаблоне
      return {
        readersNumber,
        book
      }
    }
  }
</script>
```

Как мы видем, возвращаемые из `setup` ref'ы по умолчанию неглубоко разворачиваются, так что в шаблоне не надо обращаться к полю `value`.

**Использование в render-функциях**

Функция `setup` может также возвращать render-функцию, которая сможет использовать реактивное состояние, объявленное в той же области видимости:

```js
// MyBook.vue

import { h, ref, reactive } from 'vue'

export default {
  setup() {
    const readersNumber = ref(0)
    const book = reactive({ title: 'Руководство Vue 3' })
    // Обратите внимание, здесь потребуется явно использовать значение ref
    return () => h('div', [readersNumber.value, book.title])
  }
}
```

Возвращая рендер-функцию, мы можем возвращать ничего более. Так что методы, которые реализованы в `setup`, *не могут быть использованы в шаблоне*, чтобы обращаться к ним через рефы из родительского компонента (как мы помним, родитель можем навесить реф на дочерний компонент и получить через него доступ к методам дочернего компонента!).

Тут нам и помогает `expose`, передав в эту функцию объект со свойствами, которые *должны* быть достпуны для экземпляра внешнего компонента:

```js
import { h, ref } from 'vue'

export default {
  setup(props, { expose }) {
    const count = ref(0)
    const increment = () => ++count.value

    expose({
      increment
    })

    return () => h('div', count.value)
  }
}
```

Теперь метод `increment` доступен в родительском компоненте через ссылку в шаблоне.

**Использование this**

*Внутри `setup()` использование `this` не будет ссылкой на текущий активный экземпляр.* Так как `setup()` вызывается до разрешения других опций компонента, то поведение `this` внутри `setup()` будет несколько отличаться от `this` в других опциях. Это может привести к путанице при использовании `setup()` совместно с другими Options API.