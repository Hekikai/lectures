Спецификация [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) описывает встроенный класс `EventSource`, который позволяет поддерживать соединение с сервером и получать от него события.

Как и в случае с *WebSocket*, соединение постоянно.

Но есть отличия от *WebSocket*:

1. Однонаправленность: данные посылает только сервер
2. Данные выступают только в роли текста
3. Протокол HTTP

Как видно, он куда "слабее", чем *WebSocket*. Зачем тогда его использовать? Ну, во-первых, он проще, а во-вторых - не всем нужен весь функционал WebSocket'ов. К тому же, он поддерживает автоматическое переподключение при потере соединения, которое, используя WebSocket, нам бы пришлось реализовывать самим.
 
**Получение сообщений**

Чтобы начать получать данные, нам нужно просто создать `new EventSource(url)`.

Браузер установит соединение с `url` и будет поддерживать его открытым, ожидая события.

Сервер должен ответить со статусом 200 и заголовком `Content-Type: text/event-stream`, затем он должен поддерживать соединение открытым и отправлять сообщения в особом формате:
```
data: Сообщение 1

data: Сообщение 2

data: Сообщение 3 
data: в две строки
```

-   Текст сообщения указывается после `data:`, пробел после двоеточия необязателен.
-   Сообщения разделяются двойным переносом строки `\n\n`.
-   Чтобы разделить сообщение на несколько строк, мы можем отправить несколько `data:` подряд (третье сообщение).

На практике сложные сообщения обычно отправляются в формате JSON, в котором перевод строки кодируется как `\n`, так что в разделении сообщения на несколько строк обычно нет нужды.

…Так что можно считать, что в каждом `data:` содержится ровно одно сообщение.

Для каждого сообщения генерируется событие `message`:

```js
const eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = (event) => {
	console.log("Новое сообщение", event.data);
	// этот код выведет в консоль 3 сообщения, из потока данных выше
};

// или eventSource.addEventListener('message', ...)
```

**Кросс-доменные запросы**

`EventSource`, как и `fetch`, поддерживает кросс-доменные запросы. Мы можем использовать любой URL. Сервер получит заголовок `Origin` и должен будет ответить с заголовком `Access-Control-Allow-Origin`.

Чтобы послать авторизационные данные, следует установить дополнительную опцию `withCredentials`:
```js
const source = new EventSource("https://another-site.com/events", {
	withCredentials: true
})
```

**Переподключение**

После создания `new EventSource` подключается к серверу и, если соединение обрывается, – переподключается.

Это очень удобно, так как нам не приходится беспокоиться об этом.

По умолчанию между попытками возобновить соединение будет небольшая пауза в несколько секунд.

Сервер может выставить рекомендуемую задержку, указав в ответе `retry:` (в миллисекундах):
```
retry: 15000
data: Привет, я выставил задержку переподключения в 15 секунд
```

Поле `retry:` может посылаться как вместе с данными, так и отдельным сообщением.

Браузеру следует ждать именно столько миллисекунд перед новой попыткой подключения. Или дольше, например, если браузер знает (от операционной системы) что соединения с сетью нет, то он может осуществить переподключение только когда оно появится.

-   Если сервер хочет остановить попытки переподключения, он должен ответить со статусом 204.
-   Если браузер хочет прекратить соединение, он может вызвать `eventSource.close()`:

```js
const eventSource = new EventSource(...);

eventSource.close();
```

Также переподключение не произойдёт, если в ответе указан неверный `Content-Type` или его статус отличается от 301, 307, 200 и 204. Браузер создаст событие `"error"` и не будет восстанавливать соединение. 

После того как соединение окончательно закрыто, «переоткрыть» его уже нельзя. Если необходимо снова подключиться, просто создайте новый `EventSource`.

**Идентификатор сообщения**

Когда соединение прерывается из-за проблем с сетью, ни сервер, ни клиент не могут быть уверены в том, какие сообщения были доставлены, а какие – нет.

Чтобы правильно возобновить подключение, каждое сообщение должно иметь поле `id`:
```
data: Сообщение 1 
id: 1 

data: Сообщение 2 
id: 2 

data: Сообщение 3 
data: в две строки 
id: 3
```

Получая сообщение с указанным `id:`, браузер:

-   Установит его значение свойству `eventSource.lastEventId`.
-   При переподключении отправит заголовок `Last-Event-ID` с этим `id`, чтобы сервер мог переслать последующие сообщения.

**Статус подключения: readyState**

У объекта `EventSource` есть свойство `readyState`, имеющее одно из трёх значений:
```
EventSource.CONNECTING = 0; // подключение или переподключение
EventSource.OPEN = 1;       // подключено 
EventSource.CLOSED = 2;     // подключение закрыто
```

При создании объекта и разрыве соединения оно автоматически устанавливается в значение `EventSource.CONNECTING` (равно `0`).

Мы можем обратиться к этому свойству, чтобы узнать текущее состояние `EventSource`.

**Типы событий**

По умолчанию объект `EventSource` генерирует 3 события:

-   `message` – получено сообщение, доступно как `event.data`.
-   `open` – соединение открыто.
-   `error` – не удалось установить соединение, например, сервер вернул статус 500.

Сервер может указать другой тип события с помощью `event: ...` в начале сообщения.

Например:

```
event: join 
data: Боб 

data: Привет 

event: leave 
data: Боб
```

Чтобы начать слушать пользовательские события, нужно использовать `addEventListener`, а не `onmessage`.