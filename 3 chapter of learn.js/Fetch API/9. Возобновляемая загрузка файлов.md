При помощи `fetch` достаточно просто отправить файл на сервер.

Но как возобновить загрузку, если соединение прервалось? Для этого нужен индикатор загрузки, а такое реализовать можно только с помощью XMLHttpRequest.

**Не очень полезное событие progress**

Чтобы возобновить отправку, нам нужно знать, какая часть файла была успешно передана до того, как соединение прервалось.

Можно установить обработчик `xhr.upload.onprogress`, чтобы отслеживать процесс загрузки, но, к сожалению, это бесполезно, так как этот обработчик вызывается, только когда данные _отправляются_, но были ли они получены сервером? Браузер этого не знает.

Возможно, отправленные данные оказались в буфере прокси-сервера локальной сети или удалённый сервер просто отключился и не смог принять их, или данные потерялись где-то по пути при разрыве соединения и так и не достигли пункта назначения.

В общем, событие `progress` подходит только для того, чтобы показывать красивый индикатор загрузки, не более.

Для возобновления же загрузки нужно _точно_ знать, сколько байт было получено сервером. И только сам сервер может это сказать, поэтому будем делать для этого отдельный запрос.

**Алгоритм**

1. Во-первых, создадим id для файла, который собираемся загружать:

```js
let fileId = `${file.name}-${file.size}-${file.lastModifiedDate}`;
```

Это нужно, чтобы при возобновлении загрузки серверу было понятно, какой файл мы продолжаем загружать.

Если имя или размер или дата модификация файла изменятся, то у него уже будет другой `fileId`.

2. Далее, посылаем запрос к серверу с просьбой указать количество уже полученных байтов:

```js
let response = await fetch('status', { 
	headers: { 
		'X-File-Id': fileId 
	} 
}); 

// сервер получил столько-то байтов 
let startByte = +await response.text();
```

Предполагается, что сервер учитывает загружаемые файлы с помощью заголовка `X-File-Id`. Это на стороне сервера должно быть реализовано.

Если файл серверу неизвестен, то он должен ответить `0`.

3. Затем мы можем использовать метод `slice` объекта `Blob`, чтобы отправить данные, начиная со `startByte` байта:

```js
xhr.open("POST", "upload", true); 

// Идентификатор файла, чтобы сервер знал, что мы загружаем
xhr.setRequestHeader('X-File-Id', fileId);

// Номер байта, начиная с которого мы будем отправлять данные.
// Таким образом, сервер поймёт, с какого момента мы возобновляем загрузку
xhr.setRequestHeader('X-Start-Byte', startByte); 

xhr.upload.onprogress = (e) => { 
	console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
};

// файл file может быть взят из input.files[0] или другого источника 
xhr.send(file.slice(startByte));
```

Здесь мы посылаем серверу и идентификатор файла в заголовке `X-File-Id`, чтобы он знал, что мы загружаем, и номер стартового байта в заголовке `X-Start-Byte`, чтобы он понял, что мы продолжаем отправку, а не начинаем её с нуля.

Сервер должен проверить информацию на своей стороне, и если обнаружится, что такой файл уже когда-то загружался, и его текущий размер равен значению из заголовка `X-Start-Byte`, то вновь принимаемые данные добавлять в этот файл.