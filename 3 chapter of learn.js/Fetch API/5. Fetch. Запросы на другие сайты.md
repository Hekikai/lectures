Если мы хотим получить данные с какого-нибудь сайта (наприме, *example.com*):
```js
try {
	await fetch ('http://example.com');
} catch (err) {
	console.log(err); // Failed to fetch
}
```

То у нас ничего не получится :) Все потому, что существует CORS-политика - Cross Origin Resoure Sharing ("совместное использование ресурсов между разными источниками"). 

Ключевым понятием здесь является _источник_ (origin) – комбинация домен/порт/протокол.
Запросы на другой источник - отправленные на другой домен (или даже поддомен), или протокол, или порт - требуют специальных заголовков от удаленной стороны.

CORS-политика была придумана, чтобы защитить странички от хакеров. 

**Простые запросы**
Есть два вида запросов на другой источник:
1. Простые
2. Все остальные

Простой запрос – это запрос, удовлетворяющий следующим условиям:

1.  Простой метод: GET, POST или HEAD
2.  Простые заголовки – разрешены только:
    -   `Accept`,
    -   `Accept-Language`,
    -   `Content-Language`,
    -   `Content-Type` со значением `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain`.

Любой другой запрос считается «непростым». Например, запрос с методом `PUT` или с HTTP-заголовком `API-Key` не соответствует условиям.

**Принципиальное отличие между ними состоит в том, что «простой запрос» может быть сделан через `<form>` или `<script>`, без каких-то специальных методов.**

Когда мы пытаемся сделать непростой запрос, браузер посылает специальный предварительный запрос (preflight), который спрашивает у сервера - согласен ли он принять такой непростой запрос или нет?

И, если сервер явно не даёт согласие в заголовках, непростой запрос не посылается.

**CORS для простых запросов**

При запросе на другой источник браузер сам ставит заголовок *Origin*.

Например, если мы запрашиваем `https://anywhere.com/request` со страницы `https://javascript.info/page`, заголовки будут такими:
```
GET /request
Host: anywhere.com
Origin: https://javascript.info
```

Как вы можете видеть, заголовок `Origin` содержит именно источник (домен/протокол/порт), без пути.

Сервер проверяет *Origin* и, если он готов принять такой запрос, добавляет особый заголовок *Access-Control-Allow-Origin* к ответу. Этот заголовок должен содержать разрешённый источник (в нашем случае `https://javascript.info`) или звёздочку `*`. Тогда ответ успешен, в противном случае возникает ошибка.

Браузер выступает в роли посредника:
1. Он гарантирует, что к запросу приложится корректный заголовок *Origin*.
2. Если сервер в ответе "разрешает" этому адресу посылать запрос, то браузер "сообщает" об этом скрипту, и он получает доступ к ответу с сервера.

**Заголовки ответа**

По умолчанию при запросе к другому источнику JavaScript может получить доступ только к так называемым «простым» заголовкам ответа:

-   `Cache-Control`
-   `Content-Language`
-   `Content-Type`
-   `Expires`
-   `Last-Modified`
-   `Pragma`

При доступе к любому другому заголовку ответа будет ошибка. 

Чтобы разрешить JavaScript доступ к любому другому заголовку ответа, сервер должен указать заголовок `Access-Control-Expose-Headers`. Он содержит список, через запятую, заголовков, которые не являются простыми, но доступ к которым разрешён.

Например:
```
200 OK 
Content-Type:text/html; charset=UTF-8 
Content-Length: 12345 
API-Key: 2c9de507f2c54aa1 
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
```

При таком заголовке `Access-Control-Expose-Headers`, скрипту разрешено получить заголовки `Content-Length` и `API-Key` ответа.

**"Непростые" запросы**

Никто и не подозревал, что браузер в будущем сможет делать другие запросы, а не только PUT, POST и DELETE. Так что другие запросы браузер по умолчанию не делает ("непростые" запросы), дабы не давать другим программам путаницы, что "я - не браузер!".

Предварительный запрос использует метод `OPTIONS`, у него нет тела, но есть два заголовка:

-   `Access-Control-Request-Method` содержит HTTP-метод «непростого» запроса.
-   `Access-Control-Request-Headers` предоставляет разделённый запятыми список его «непростых» HTTP-заголовков.

Если сервер согласен принимать такие запросы, то он должен ответить без тела, со статусом 200 и с заголовками:

-   `Access-Control-Allow-Methods` должен содержать разрешённые методы.
-   `Access-Control-Allow-Headers` должен содержать список разрешённых заголовков.
-   Кроме того, заголовок `Access-Control-Max-Age` может указывать количество секунд, на которое нужно кешировать разрешения. Так что браузеру не придётся посылать предзапрос для последующих запросов, удовлетворяющих данным разрешениям.

![[Pasted image 20220301083719.png]]

Рассмотрим пошагово, что творится, если делать "непростой" запросы из JavaScript.
```js
const response = await fetch('https://site.com/service.json', {
	method: 'PATCH', // обновление данных
	headers: {
		'Content-Type': 'application/json',
		'API-Key': 'secret'
	}
})
```
Этот запрос не является простым по трём причинам (достаточно одной):

-   Метод `PATCH`
-   `Content-Type` не один из: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`.
-   Содержит «непростой» заголовок `API-Key`.

Шаг 1 - предзапрос

Перед тем, как послать такой запрос, браузер самостоятельно генерирует и посылает предзапрос, который выглядит следующим образом:
```
OPTIONS /service.json 
Host: site.com 
Origin: https://javascript.info 
Access-Control-Request-Method: PATCH 
Access-Control-Request-Headers: Content-Type,API-Key
```

Шаг 2 - ответ сервера на предзапрос

Сервер должен ответить со статусом 200 и заголовками:

-   `Access-Control-Allow-Methods: PATCH`
-   `Access-Control-Allow-Headers: Content-Type,API-Key`.

Это разрешит будущую коммуникацию, в противном случае возникает ошибка.

Если сервер ожидает в будущем другие методы и заголовки, то он может в ответе перечислить их все сразу, разрешить заранее, например:
```
200 OK
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
```

Теперь, когда браузер видит, что `PATCH` есть в `Access-Control-Allow-Methods`, а `Content-Type,API-Key` – в списке `Access-Control-Allow-Headers`, он посылает наш основной запрос.

Кроме того, ответ на предзапрос кешируется на время, указанное в заголовке `Access-Control-Max-Age` (86400 секунд, один день), так что последующие запросы не вызовут предзапрос. Они будут отосланы сразу при условии, что соответствуют закешированным разрешениям.

Шаг 3 - основной запрос

Если предзапрос успешен, браузер делает основной запрос. Алгоритм здесь такой же, что и для простых запросов.

Основной запрос имеет заголовок `Origin` (потому что он идёт на другой источник):
```
PATCH /service.json 
Host: site.com 
Content-Type: application/json 
API-Key: secret 
Origin: https://javascript.info
```

Шаг 4 - основной ответ

Сервер не должен забывать о добавлении `Access-Control-Allow-Origin` к ответу на основной запрос. Успешный предзапрос не освобождает от этого:
```
Access-Control-Allow-Origin: https://javascript.info
```

После этого JavaScript может прочитать ответ сервера.

****
Предзапрос осуществляется «за кулисами», невидимо для JavaScript.

JavaScript получает только ответ на основной запрос или ошибку, если со стороны сервера нет разрешения.
****

**Авторизационные данные**

Запрос на другой источник по умолчанию не содержит авторизационных данных (credentials), под которыми здесь понимаются куки и заголовки HTTP-аутентификации.

Например, `fetch('http://another.com')` не посылает никаких куки, даже тех (!), которые принадлежат домену `another.com`.

Почему?

Потому что запрос с авторизационными данными даёт намного больше возможностей, чем без них. Если он разрешён, то это позволяет JavaScript действовать от имени пользователя и получать информацию, используя его авторизационные данные.

Действительно ли сервер настолько доверяет скрипту? Тогда он должен явно разрешить такие запросы при помощи дополнительного заголовка.

Чтобы включить отправку авторизационных данных в `fetch`, нам нужно добавить опцию `credentials: "include"`, вот так:
```js
fetch('https://another.com', {
	credentials: "include"
});
```

Теперь `fetch` пошлёт куки с домена `another.com` вместе с нашим запросом на этот сайт.

Если сервер согласен принять запрос _с авторизационными данными_, он должен добавить заголовок `Access-Control-Allow-Credentials: true` к ответу, в дополнение к `Access-Control-Allow-Origin`.

Например:
```
200 OK 
Access-Control-Allow-Origin: 
https://javascript.info 
Access-Control-Allow-Credentials: true
```

Пожалуйста, обратите внимание: в `Access-Control-Allow-Origin` запрещено использовать звёздочку `*` для запросов с авторизационными данными. Там должен быть именно источник, как показано выше. Это дополнительная мера безопасности, чтобы гарантировать, что сервер действительно знает, кому он доверяет делать такие запросы.