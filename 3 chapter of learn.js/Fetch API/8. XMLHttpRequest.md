XMLHttpRequest - класс в JavaScript, который позволяет делать асинхронные (чаще всего) и синхронные (не очень удобные) запросы на сервер. 

Ему есть более новая замена - *fetch* - но она не всегда используется. Почему? Есть три причины:
1. Много легаси кода, написанного на XMLHttpRequest, так что его нужно поддерживать
2. Необходимость поддержки старых браузеров и нежелание использовать полифилы
3. А также фича, которой нет (пока, во всяком случае) у *fetch*'а - отслеживание прогресса загрузки.

**Основы**

Чтобы сделать запрос, нужно пройти несколько шагов:
1. Создать XMLHttpRequest:

```js
const xhr = new XMLHttpRequest(); //у конструктора нет аргументов
```

2. Инициализировать его:

```js
xhr.open(method, URL [, async, user, password]);
```

Этот метод обычно вызывается сразу после `new XMLHttpRequest`. В него передаются основные параметры запроса:

-   `method` – HTTP-метод. Обычно это `"GET"` или `"POST"`.
-   `URL` – URL, куда отправляется запрос: строка, может быть и объект [URL](https://learn.javascript.ru/url).
-   `async` – если указать `false`, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже.
-   `user`, `password` – логин и пароль для базовой HTTP-авторизации (если требуется).

Заметим, что вызов `open`, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно отсылается запрос только лишь после вызова `send`.

3. Послать запрос

```js
xhr.send([body])
```

Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр `body` содержит тело запроса.
Некоторые типы запросов, такие как `GET`, не имеют тела. А некоторые, как, например, `POST`, используют `body`, чтобы отправлять данные на сервер. Мы позже увидим примеры.

4. Далее нужно слушать события, чтобы получить и обработать ответ:

Три наиболее используемых события:

-   `load` – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.
-   `error` – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.
-   `progress` – происходит периодически во время загрузки ответа, сообщает о прогрессе.

После ответа сервера мы можем получить результат запроса в следующих свойствах `xhr`:

`status`

Код состояния HTTP (число): `200`, `404`, `403` и так далее, может быть `0` в случае, если ошибка не связана с HTTP.

`statusText`

Сообщение о состоянии ответа HTTP (строка): обычно `OK` для `200`, `Not Found` для `404`, `Forbidden` для `403`, и так далее.

`response` (в старом коде может встречаться как `responseText`)

Тело ответа сервера.

Мы можем также указать таймаут – промежуток времени, который мы готовы ждать ответ:
```js
xhr.timeout = 10000; // таймаут указывается в миллисекундах, т.е. 10 секунд
```

Если запрос не успевает выполниться в установленное время, то он прерывается, и происходит событие `timeout`.

**Тип ответа**

Мы можем использовать свойство `xhr.responseType`, чтобы указать ожидаемый тип ответа:

-   `""` (по умолчанию) – строка,
-   `"text"` – строка,
-   `"arraybuffer"` – `ArrayBuffer` (для бинарных данных, смотрите в [ArrayBuffer, бинарные массивы](https://learn.javascript.ru/arraybuffer-binary-arrays)),
-   `"blob"` – `Blob` (для бинарных данных, смотрите в [Blob](https://learn.javascript.ru/blob)),
-   `"document"` – XML-документ (может использовать XPath и другие XML-методы),
-   `"json"` – JSON (парсится автоматически).

**Состояния запроса**

У `XMLHttpRequest` есть состояния, которые меняются по мере выполнения запроса. Текущее состояние можно посмотреть в свойстве `xhr.readyState`.

Список всех состояний, указанных в [спецификации](https://xhr.spec.whatwg.org/#states):
```js
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open 
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены) 
DONE = 4; // запрос завершён
```

Состояния объекта `XMLHttpRequest` меняются в таком порядке: `0` → `1` → `2` → `3` → … → `3` → `4`. Состояние `3` повторяется каждый раз, когда получена часть данных.

Изменения в состоянии объекта запроса генерируют событие `readystatechange`, которое нужно слушать, чтобы узнать об изменении состояния объекта.

Но сейчас используют чаще всего `load/progress/error`, а `readystatechange` "морально устарело".

**Отмена запроса**

Чтобы отменить запрос тогда, когда нам нужно, стоит всего лишь вызвать метод `abort()`:
```js
xhr.abort();
```

При этом генерируется событие `abort`, а `xhr.status` устанавливается в `0`.

**Синхронные запросы**

Если в методе `open` третий параметр `async` установлен на `false`, запрос выполняется синхронно.

Другими словами, выполнение JavaScript останавливается на `send()` и возобновляется после получения ответа. Так ведут себя, например, функции `alert` или `prompt`.

Очевидно, что такое поведение нежелательно, так как начинает все "виснуть". Пока не получим ответ на запрос, то браузер "встанет" на месте => пользователь будет ждать, не имея возможности интерактивного взаимодействия со страницей.

**HTTP-заголовки**

XMLHttpRequest умеет как указывать сво заголовки в запросе, так и читать присланные в ответ. Некоторые заголовки управляются самим браузером и поставить мы их вручную не можем! (Referer или Host).

Для работы с HTTP-заголовками есть 3 метода:

`setRequestHeader(name, value)`

Устанавливает заголовок запроса с именем `name` и значением `value`.

Например:
```js
xhr.setRequestHeader('Content-Type', 'application/json');
```

Снять установленный заголовок никак нельзя! Это ещё одна из особенностей XMLHttpRequest. Повторные вызовы лишь добавляют информацию к заголовку, а не перезаписывают его.

`getResponseHeader(name)`

Возвращает значение заголовка ответа `name` (кроме `Set-Cookie` и `Set-Cookie2`).
Например:

```js
xhr.getResponseHeader('Content-Type')
```

`getAllResponseHeaders()`

Возвращает все заголовки ответа, кроме `Set-Cookie` и `Set-Cookie2`.

Заголовки возвращаются в виде единой строки, например:
```js
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
```

Между заголовками всегда стоит перевод строки в два символа `"\r\n"` (независимо от ОС), так что мы можем легко разделить их на отдельные заголовки. Значение заголовка всегда отделено двоеточием с пробелом `": "`. Этот формат задан стандартом.

Таким образом, если хочется получить объект с парами заголовок-значение, нам нужно задействовать немного JS.

Вот так (предполагается, что если два заголовка имеют одинаковое имя, то последний перезаписывает предыдущий):
```js
let headers = xhr .getAllResponseHeaders()
	.split('\r\n') 
	.reduce((result, current) => {
		let [name, value] = current.split(': ');
		result[name] = value;
		return result; 
	}, {}); 

// headers['Content-Type'] = 'image/png'
```

**POST, FormData**

Чтобы сделать POST-запрос, мы можем использовать встроенный класс FormData.

```js
const formData = new FormData([form]); // создаем объект, по желанию берём данные формы <form>
formData.append(name, value); // добавляем поле
```

Мы создаём объект, при желании указываем, из какой формы `form` взять данные, затем, если нужно, с помощью метода `append` добавляем дополнительные поля, после чего:

1.  `xhr.open('POST', ...)` – создаём `POST`-запрос.
2.  `xhr.send(formData)` – отсылаем форму серверу.

Обычно форма отсылается в кодировке `multipart/form-data`.

Если нам больше нравится формат JSON, то используем `JSON.stringify` и отправляем данные как строку.

Важно не забыть поставить соответствующий заголовок `Content-Type: application/json`, многие серверные фреймворки автоматически декодируют JSON при его наличии.

Метод `.send(body)` весьма всеяден. Он может отправить практически что угодно в `body`, включая объекты типа `Blob` и `BufferSource`.

**Прогресс отправки**

Событие `progress` срабатывает только на стадии загрузки ответа с сервера.

А именно: если мы отправляем что-то через `POST`-запрос, `XMLHttpRequest` сперва отправит наши данные (тело запроса) на сервер, а потом загрузит ответ сервера. И событие `progress` будет срабатывать только во время загрузки ответа.

Если мы отправляем что-то большое, то нас гораздо больше интересует прогресс отправки данных на сервер. Но `xhr.onprogress` тут не поможет.

Существует другой объект, без методов, только для отслеживания событий отправки: `xhr.upload`.

Он генерирует события, похожие на события `xhr`, но только во время отправки данных на сервер:

-   `loadstart` – начало загрузки данных.
-   `progress` – генерируется периодически во время отправки на сервер.
-   `abort` – загрузка прервана.
-   `error` – ошибка, не связанная с HTTP.
-   `load` – загрузка успешно завершена.
-   `timeout` – вышло время, отведённое на загрузку (при установленном свойстве `timeout`).
-   `loadend` – загрузка завершена, вне зависимости от того, как – успешно или нет.

Примеры обработчиков для этих событий:
```js
xhr.upload.onprogress = function(event) { 
	alert(`Отправлено ${event.loaded} из ${event.total} байт`); 
}; 

xhr.upload.onload = function() { 
	alert(`Данные успешно отправлены.`);
}; 

xhr.upload.onerror = function() { 
	alert(`Произошла ошибка во время отправки: ${xhr.status}`);
};
```

**Запросы на другой источник**

`XMLHttpRequest` может осуществлять запросы на другие сайты, используя ту же политику CORS, что и `fetch`.

Точно так же, как и при работе с `fetch`, по умолчанию на другой источник не отсылаются куки и заголовки HTTP-авторизации. Чтобы это изменить, установите `xhr.withCredentials` в `true`:
```js
let xhr = new XMLHttpRequest(); 
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request'); 
```