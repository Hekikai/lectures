Чтобы получать данные или же самому отправлять их, в JavaScript есть удобный и мощный API - fetch.

Синтаксис:
```js
const promise = fetch(url [, options]);
```

- *url* - URL для отправки запроса.
- *options* - дополнительные параметры: метод, заголовки и так далее.

Без *options* это просто GET-запрос, скачивающий содержимое по адресу *url*.

Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

Как только сервер присылает заголовки ответа, то *promise* выполняется с объектом встроенного класса Response. На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа. 

Промис завершается с ошибкой, если `fetch` не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.

Мы можем увидеть HTTP-статус в свойствах ответа:

-   **`status`** – код статуса HTTP-запроса, например 200.
-   **`ok`** – логическое значение: будет `true`, если код HTTP-статуса в диапазоне 200-299.

Именно поэтому мы можем обработать этот ответ с помощью различных методов.
- **`response.text()`** – читает ответ и возвращает как обычный текст,
-   **`response.json()`** – декодирует ответ в формате JSON,
-   **`response.formData()`** – возвращает ответ как объект `FormData` (разберём его в [следующей главе](https://learn.javascript.ru/formdata)),
-   **`response.blob()`** – возвращает объект как [Blob](https://learn.javascript.ru/blob) (бинарные данные с типом),
-   **`response.arrayBuffer()`** – возвращает ответ как [ArrayBuffer](https://learn.javascript.ru/arraybuffer-binary-arrays) (низкоуровневое представление бинарных данных),
-   помимо этого, `response.body` – это объект [ReadableStream](https://streams.spec.whatwg.org/#rs-class), с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.


**Заголовки ответа**

Заголовки ответа хранятся в похожем на `Map` объекте `response.headers`.

Это не совсем `Map`, но мы можем использовать такие же методы, как с `Map`, чтобы получить заголовок по его имени или перебрать заголовки в цикле

**Заголовки запроса**

Для установки заголовка запроса в `fetch` мы можем использовать опцию `headers`. Она содержит объект с исходящими заголовками, например:
```js
const response = fetch(protectedURL, {
	headers: {
		Authentication: 'secret'
	}
});
```

Есть список [запрещённых HTTP-заголовков](https://fetch.spec.whatwg.org/#forbidden-header-name), которые мы не можем установить. Эти заголовки обеспечивают достоверность данных и корректную работу протокола HTTP, поэтому они контролируются исключительно браузером.

**POST-запросы**

Для отправки `POST`-запроса или запроса с другим методом, нам необходимо использовать `fetch` параметры:

-   **`method`** – HTTP метод, например `POST`,
-   **`body`** – тело запроса, одно из списка:
    -   строка (например, в формате JSON),
    -   объект `FormData` для отправки данных как `form/multipart`,
    -   `Blob`/`BufferSource` для отправки бинарных данных,
    -   [URLSearchParams](https://learn.javascript.ru/url) для отправки данных в кодировке `x-www-form-urlencoded`, используется редко.