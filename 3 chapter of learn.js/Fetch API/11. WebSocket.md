Начнем с того, что WebSocket - это специальный протокол, с помощью которого можно общаться браузеру и серверу через постоянное соединение.
Данные передаются в виде пакетов в обоих направлениях, без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

**Пример**

Чтобы открыть веб-сокет соединение, нам нужно создать объект *new WebSocket(url)*, указав в url-адресе специальный протокол *ws*:

```js
const socker = new WebSocket('ws://javascript.info');
```

Также существует протокол `wss://`, использующий шифрование. Это как HTTPS для веб-сокетов. Лучше всегда использовать его :)

После того, как мы создали объект, нам нужно слушать 4 его события:

-   **`open`** – соединение установлено,
-   **`message`** – получены данные,
-   **`error`** – ошибка,
-   **`close`** – соединение закрыто.

…А если мы хотим отправить что-нибудь, то вызов `socket.send(data)` сделает это.

**Открытие веб-сокета**

Когда объект *new WebSocket* создан, он тут же начинает устанавливать соединение. Сначала браузер по HTTP-запросу с определенными заголовками спрашивает сервер: "Хочешь пообщаться по WebSocket?". Если сервер отвечает положительно, то "включается" протокол WebSocket.

Вот пример заголовков для запроса, который делает `new WebSocket("wss://javascript.info/chat")`.
```
GET /chat 
Host: javascript.info 
Origin: https://javascript.info 
Connection: Upgrade 
Upgrade: websocket 
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q== 
Sec-WebSocket-Version: 13
```

-   `Origin` – источник текущей страницы (например `https://javascript.info`). Объект WebSocket по своей природе не завязан на текущий источник. Нет никаких специальных заголовков или других ограничений. Старые сервера все равно не могут работать с WebSocket, поэтому проблем с совместимостью нет. Но заголовок `Origin` важен, так как он позволяет серверу решать, использовать ли WebSocket с этим сайтом.
-   `Connection: Upgrade` – сигнализирует, что клиент хотел бы изменить протокол.
-   `Upgrade: websocket` – запрошен протокол «websocket».
-   `Sec-WebSocket-Key` – случайный ключ, созданный браузером для обеспечения безопасности.
-   `Sec-WebSocket-Version` – версия протокола WebSocket, текущая версия 13.

Мы не можем использовать`XMLHttpRequest` или `fetch` для создания такого HTTP-запроса просто потому, что JavaScript не позволяет устанавливать такие заголовки.

Если сервер согласен, то он должен отправить в ответ 101 код:
```
101 Switching Protocols 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
```

Здесь `Sec-WebSocket-Accept` – это `Sec-WebSocket-Key`, перекодированный с помощью специального алгоритма. Браузер использует его, чтобы убедиться, что ответ соответствует запросу.

После этого данные передаются по протоколу WebSocket, и вскоре мы увидим его структуру («фреймы»). И это вовсе не HTTP.

**Расширения и подпротоколы**

Могут быть дополнительные заголовки `Sec-WebSocket-Extensions` и `Sec-WebSocket-Protocol`, описывающие расширения и подпротоколы.

Например:

-   `Sec-WebSocket-Extensions: deflate-frame` означает, что браузер поддерживает сжатие данных. Расширение – это что-то, связанное с передачей данных, расширяющее сам протокол WebSocket. Заголовок `Sec-WebSocket-Extensions` отправляется браузером автоматически со списком всевозможных расширений, которые он поддерживает.
    
-   `Sec-WebSocket-Protocol: soap, wamp` означает, что мы будем передавать не только произвольные данные, но и данные в протоколах [SOAP](http://en.wikipedia.org/wiki/SOAP) или WAMP (The WebSocket Application Messaging Protocol" – «протокол обмена сообщениями WebSocket приложений»). То есть, этот заголовок описывает не передачу, а формат данных, который мы собираемся использовать. Официальные подпротоколы WebSocket регистрируются в [каталоге IANA](http://www.iana.org/assignments/websocket/websocket.xml).
    
Этот необязательный заголовок ставим мы сами, передавая массив подпротоколов вторым параметром `new WebSocket`, вот так:

```js
const socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);
```

Сервер должен ответить перечнем протоколов и расширений, которые он может использовать.

Например, запрос:

```
GET /chat 
Host: javascript.info 
Upgrade: websocket 
Connection: Upgrade 
Origin: https://javascript.info 
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q== 
Sec-WebSocket-Version: 13
Sec-WebSocket-Extensions: deflate-frame 
Sec-WebSocket-Protocol: soap, wamp
```

Ответ:
```
101 Switching Protocols 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
Sec-WebSocket-Extensions: deflate-frame 
Sec-WebSocket-Protocol: soap
```

Здесь сервер отвечает, что поддерживает расширение – deflate-frame и может использовать только протокол SOAP из всего списка запрошенных подпротоколов.

**Передача данных**

Поток данных в WebSocket состоит из «фреймов», фрагментов данных, которые могут быть отправлены любой стороной, и которые могут быть следующих видов:

-   «текстовые фреймы» – содержат текстовые данные, которые стороны отправляют друг другу.
-   «бинарные фреймы» – содержат бинарные данные, которые стороны отправляют друг другу.
-   «пинг-понг фреймы» используется для проверки соединения; отправляется с сервера, браузер реагирует на них автоматически.
-   также есть «фрейм закрытия соединения» и некоторые другие служебные фреймы.

В браузере мы напрямую работаем только с текстовыми и бинарными фреймами.

**Метод WebSocket `.send()` может отправлять и текстовые и бинарные данные.**

Вызов `socket.send(body)` принимает `body` в виде строки или любом бинарном формате включая `Blob`, `ArrayBuffer` и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.

**При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: `Blob` или `ArrayBuffer`.**

Это задаётся свойством `socket.binaryType`, по умолчанию оно равно `"blob"`, так что бинарные данные поступают в виде `Blob`-объектов.

**Ограничение скорости**

Представим, что наше приложение генерирует много данных для отправки. Но у пользователя медленное соединение, возможно, он в интернете с мобильного телефона и не из города.

Мы можем вызывать `socket.send(data)` снова и снова. Но данные будут буферизованы (сохранены) в памяти и отправлены лишь с той скоростью, которую позволяет сеть.

Свойство `socket.bufferedAmount` хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети.

Мы можем изучить его, чтобы увидеть, действительно ли сокет доступен для передачи.

```js
// каждые 100мс проверить сокет и отправить больше данных,
// только если все текущие отосланы
setInterval( () => {
	if (socket.bufferedAmount == 0) {
		socket.send(moreData());
	}
}, 100);
```

**Закрытие подключения**

Обычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они отправляют «фрейм закрытия соединения» с кодом закрытия и указывают причину в виде текста.

Метод для этого:
```
socket.close([code], [reason]);
```
-   `code` – специальный WebSocket-код закрытия (не обязателен).
-   `reason` – строка с описанием причины закрытия (не обязательна).

Затем противоположная сторона в обработчике события `close` получит и код `code` и причину `reason`.

`code` – это не любое число, а специальный код закрытия WebSocket.

Наиболее распространённые значения:

-   `1000` – по умолчанию, нормальное закрытие,
-   `1006` – невозможно установить такой код вручную, указывает, что соединение было потеряно (нет фрейма закрытия).

Есть и другие коды:

-   `1001` – сторона отключилась, например сервер выключен или пользователь покинул страницу,
-   `1009` – сообщение слишком большое для обработки,
-   `1011` – непредвиденная ошибка на сервере,
-   …и так далее.

Полный список находится в [RFC6455, §7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1).

**Состояние соединения**

Чтобы получить состояние соединения, существует дополнительное свойство `socket.readyState` со значениями:

-   **`0`** – «CONNECTING»: соединение ещё не установлено,
-   **`1`** – «OPEN»: обмен данными,
-   **`2`** – «CLOSING»: соединение закрывается,
-   **`3`** – «CLOSED»: соединение закрыто.

