На первый взгляд квантификаторы – это просто, но на самом деле это не совсем так.

Нужно очень хорошо разбираться, как работает поиск, если планируем искать что-то сложнее, чем `/\d+/`.

Давайте в качестве примера рассмотрим следующую задачу:

У нас есть текст, в котором нужно заменить все кавычки `"..."` на «ёлочки» `«...»`, которые используются в типографике многих стран.

Например: `"Привет, мир"` должно превратиться в `«Привет, мир»`. Есть и другие кавычки, вроде `„Witam, świat!”` (польский язык) или `「你好，世界」` (китайский язык), но для нашей задачи давайте выберем `«...»`.

Первое, что нам нужно – это найти строки с кавычками, а затем мы сможем их заменить.

Регулярное выражение вроде `/".+"/g` (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так!

Давайте это проверим:

```js
const regexp = /".+"/g;

const str = 'a "witch" and her "broom" is one';

console.log( str.match(regexp) ); // "witch" and her "broom"
```

…Как мы видим, регулярное выражение работает не как задумано!

Вместо того, чтобы найти два совпадения `"witch"` и `"broom"`, было найдено одно:`"witch" and her "broom"`.

Причину можно описать, как «жадность – причина всех зол».

**Жадный поиск**

Чтобы найти совпадение, движок регулярных выражений работает по следующему алгоритму:

-   Для каждой позиции в строке для поиска:
    -   Попробовать найти совпадение с шаблоном на этой позиции.
    -   Если нет совпадения, переход к следующей позиции.

Эти общие слова никак не объясняют, почему регулярное выражение работает неправильно, так что давайте разберём подробно, как работает шаблон `".+"`.

1.  Первый символ шаблона – это кавычка `"`.
    
Движок регулярного выражения пытается найти его на нулевой позиции исходной строки `a "witch" and her "broom" is one`, но там – `a`, так что совпадения нет.
    
Он продолжает: двигается к следующей позиции исходной строки и пытается найти первый символ шаблона там. У него не получается, он двигается дальше и, наконец, находит кавычку на третьей позиции.

2. Кавычка замечена, после чего движок пытается найти совпадение для оставшегося шаблона. Смотрит, удовлетворяет ли остаток строки шаблону `.+"`.

В нашем случае следующий символ шаблона: `.` (точка). Она обозначает «любой символ, кроме новой строки», так что следующая буква строки `'w'` подходит.

3. Затем точка повторяется из-за квантификатора `.+`. Движок регулярного выражения добавляет к совпадению один символ за другим.

…До каких пор? Точке соответствуют любые символы, так что движок остановится только тогда, когда достигнет конца строки.

4. Тогда он перестанет повторять `.+` и попробует найти следующий символ шаблона. Это кавычка `"`. Но есть проблема: строка для поиска закончилась, больше нет символов!

Движок регулярного выражения понимает, что захватил слишком много `.+` и начинает _отступать_.

Другими словами, он сокращает совпадение по квантификатору на один символ.

5. Движок продолжает возвращаться: он уменьшает количество повторений `'.'`, пока оставшийся шаблон (в нашем случае `'"'`) не совпадёт.
6. Совпадение найдено.
    
7. Так что первое совпадение: `"witch" and her "broom"`. Если у регулярного выражения стоит флаг `g`, то поиск продолжится с того места, где закончился предыдущий. В оставшейся строке `is one` нет кавычек, так что совпадений больше не будет.

**В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.**

Движок регулярного выражения пытается получить максимальное количество символов, соответствующих `.+`, а затем сокращает это количество символ за символом, если остаток шаблона не совпадает.

В нашей задаче мы хотим другого. И нам поможет ленивый режим квантификатора.

**Ленивый режим**

«Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».

Мы можем включить его, вставив знак вопроса `'?'` после квантификатора, то есть будет `*?` или `+?` или даже `??` для `'?'`.

Проясним: обычно знак вопроса `?` сам по себе является квантификатором (ноль или один), но, если он добавлен _после другого квантификатора (или даже после самого себя)_, он получает другое значение – он меняет режим совпадения с жадного на ленивый.

Регулярное выражение `/".+?"/g` работает как задумано, оно находит `"witch"` и `"broom"`:

```js
const regexp = /".+?"/g;

const str = 'a "witch" and her "broom" is one';

console.log( str.match(regexp) ); // witch, broom
```

**Альтернативный подход**

С регулярными выражениями часто есть несколько путей добиться одного и того же результата.

В нашем случаем мы можем найти кавычки без использования ленивого режима с помощью регулярного выражения `"[^"]+"`.

Регулярное выражение `"[^"]+"` получит нужный результат, потому что оно ищет кавычку `'"'`, за которой следует один или несколько символов «не-кавычек» `[^"]`, а затем – закрывающая кавычка.

Движок регулярного выражения набирает, сколько может, `[^"]+`, пока не встречает закрывающую кавычку, на которой останавливается.