Некоторые регулярные выражения, простые с виду, могут выполняться оооочень долго, и даже «подвешивать» интерпретатор JavaScript.

Рано или поздно с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение – проще простого.

Типичный симптом: регулярное выражение обычно работает нормально, но иногда, с некоторыми строками, «подвешивает» интерпретатор и потребляет 100% процессора.

**Запрет возврата**

Переписывать регулярное выражение не всегда удобно, и не всегда очевидно, как это сделать.

Альтернативный подход заключается в том, чтобы запретить возврат для квантификатора.

Движок регулярных выражений проверяет множество вариантов, которые для человека являются очевидно ошибочными.

Например, в шаблоне `(\d+)*$` для человека очевидно, что в `(\d+)*` не нужно «откатывать» `+`. От того, что вместо одного `\d+` у нас будет два независимых `\d+\d+`, ничего не изменится:

```
\d+........ 
(123456789)! 

\d+...\d+.... 
(1234)(56789)!
```

В современных регулярных выражениях для решения этой проблемы придумали захватывающие (possessive) квантификаторы, которые такие же как жадные, но не делают возврат (то есть, по сути, они даже проще, чем жадные).

Также есть «атомарные скобочные группы» – средство, запрещающее возврат внутри скобок.

К сожалению, в JavaScript они не поддерживаются, но есть другое средство.

**Опережающая проверка в помощь!**

Шаблон, захватывающий максимальное количество повторений `\w` без возврата, выглядит так: `(?=(\w+))\1`.

Расшифруем его:

-   Опережающая проверка `?=` ищет максимальное количество `\w+`, доступных с текущей позиции.
-   Содержимое скобок вокруг `?=...` не запоминается движком, поэтому оборачиваем `\w+` внутри в дополнительные скобки, чтобы движок регулярных выражений запомнил их содержимое.
-   …И чтобы далее в шаблоне на него сослаться обратной ссылкой `\1`.

То есть, мы смотрим вперед – и если там есть слово `\w+`, то ищем его же `\1`.

Зачем? Всё дело в том, что опережающая проверка находит слово `\w+` целиком, и мы захватываем его в шаблон посредством `\1`. Поэтому мы реализовали, по сути, захватывающий квантификатор `+`. Такой шаблон захватывает только полностью слово `\w+`, не его часть.

Например, в слове `JavaScript` он не может захватить только `Java`, и оставить `Script` для совпадения с остатком шаблона.