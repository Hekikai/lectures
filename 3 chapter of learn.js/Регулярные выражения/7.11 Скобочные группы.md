Можно объединять символы в регулярных выражениях в `(...)`. Есть два эффекта от такого выделения:
1. Если поставить квантификатор после скобочек, то он применется ко всему содержимому скобочек, а не к одному символу.
2. Позволяет поместить часть совпадений в массив.

**Примеры**

1. Возьмём строку `gogogo`.

Без скобок шаблон `go+` означает символ `g` и идущий после него символ `o`, который повторяется один или более раз. Например, `goooo` или `gooooooooo`.

Так что воспользуемся скобочной группой:

```js
alert( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"
```

2. Попробуем сделать регулярное выражение, соответствующее домену сайта.

Например:
```
mail.com 
users.mail.com 
smith.users.mail.com
```

На языке регулярных выражений:

```js
/(\w+\.)+\w+/g;
```

Поиск работает, но такому шаблону не соответствует домен с дефисом, например, `my-site.com`, так как дефис не входит в класс `\w`.

Можно исправить это, заменим `\w` на `[\w-]` везде, кроме как в конце: `([\w-]+\.)+\w+`.

3. Email

Предыдущий пример можно расширить, создав регулярное выражение для поиска email.

Формат email: `имя@домен`. В качестве имени может быть любое слово, разрешены дефисы и точки. На языке регулярных выражений это `[-.\w]+`.

Шаблон будет выглядеть:

```js
const regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

console.log("my@mail.com @ his@site.com.uk".match(regexp)); 
// my@mail.com, his@site.com.uk
```

**Содержимое скобок в match**

Скобочные группы нумеруются слева направо. Поисковый движок запоминает содержимое, которое соответствует каждой скобочной группе, и позволяет получить его в результате.

Метод `str.match(regexp)`, если у регулярного выражения `regexp` нет флага `g`, ищет первое совпадение и возвращает его в виде массива:

1.  На позиции `0` будет всё совпадение целиком.
2.  На позиции `1` – содержимое первой скобочной группы.
3.  На позиции `2` – содержимое второй скобочной группы.
4.  …и так далее…

Получим содержимое тега и тег целиком!

```js
const str = '<h1>Hello, world!</h1>';

const tag = str.match(/<(.*?)>/);
```

**Вложенные группы**

Скобки могут быть и вложенными.

Например, при поиске тега в `<span class="my">` нас может интересовать:

1.  Содержимое тега целиком: `span class="my"`.
2.  Название тега: `span`.
3.  Атрибуты тега: `class="my"`.

Заключим их в скобки в шаблоне: `<(([a-z]+)\s*([^>]*))>`.

```js
const str = '<span class="my">';

const regexp = /<(([a-z]+)\s*([^>]*))>/;

const result = str.match(regexp); 
console.log(result[0]); // <span class="my"> 
console.log(result[1]); // span class="my" 
console.log(result[2]); // span 
console.log(result[3]); // class="my"
```

**Необязательные группы**

Даже если скобочная группа необязательна (например, стоит квантификатор `(...)?`), соответствующий элемент массива `result` существует и равен `undefined`.

Например, рассмотрим регулярное выражение `a(z)?(c)?`. Оно ищет букву `"a"`, за которой идёт необязательная буква `"z"`, за которой, в свою очередь, идёт необязательная буква `"c"`.

**Поиск всех совпадений с группами: matchAll**

Этот метод является новым, может потребоваться полифил.

При поиске всех совпадений (флаг `g`) метод `match` не возвращает скобочные группы.

Например, попробуем найти все теги в строке:
```js
const str = '<h1> <h2>'; 

const tags = str.match(/<(.*?)>/g); 

console.log( tags ); // <h1>,<h2>
```

Результат – массив совпадений, но без деталей о каждом. Но на практике скобочные группы тоже часто нужны.

Для того, чтобы их получать, мы можем использовать метод `str.matchAll(regexp)`.

Он был добавлен в язык JavaScript гораздо позже чем `str.match`, как его «новая и улучшенная» версия.

Он, как и `str.match(regexp)`, ищет совпадения, но у него есть три отличия:

1.  Он возвращает не массив, а перебираемый объект.
2.  При поиске с флагом `g`, он возвращает каждое совпадение в виде массива со скобочными группами.
3.  Если совпадений нет, он возвращает не `null`, а просто пустой перебираемый объект.

Например:

```js
const results = '<h1> <h2>'.matchAll(/<(.*?)>/gi); 

// results - не массив, а перебираемый объект 
console.log(results); // [object RegExp String Iterator] 

console.log(results[0]); // undefined (*) 

results = Array.from(results); // превращаем в массив 

console.log(results[0]); // <h1>,h1 (первый тег) 
console.log(results[1]); // <h2>,h2 (второй тег)
```

**Именованные группы**

Запоминать группы по номерам не очень удобно. Для простых шаблонов это допустимо, но в сложных регулярных выражениях считать скобки затруднительно. Гораздо лучше – давать скобкам имена.

Это делается добавлением `?<name>` непосредственно после открытия скобки.

Например, поищем дату в формате «год-месяц-день»:

```js
const dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;

const str = "2019-04-30";

const groups = str.match(dateRegexp).groups;

console.log(groups.year); // 2019 
console.log(groups.month); // 04 
console.log(groups.day); // 30
```

**Скобочные группы при замене**

Метод `str.replace(regexp, replacement)`, осуществляющий замену совпадений с `regexp` в строке `str`, позволяет использовать в строке замены содержимое скобок. Это делается при помощи обозначений вида `$n`, где `n` – номер скобочной группы.

Например:

```js
const str = "John Bull"; 
const regexp = /(\w+) (\w+)/; 

console.log( str.replace(regexp, '$2, $1') ); // Bull, John
```

Для именованных скобок ссылка будет выглядеть как `$<имя>`.

Например, заменим даты в формате «год-месяц-день» на «день.месяц.год»:

```js
const regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g; 

const str = "2019-10-30, 2020-01-01"; 

console.log( str.replace(regexp, '$<day>.$<month>.$<year>') ); 
// 30.10.2019, 01.01.2020
```

**Исключение из запоминания через ?:**

Бывает так, что скобки нужны, чтобы квантификатор правильно применился, но мы не хотим, чтобы их содержимое было выделено в результате.

Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало `?:`.

Например, если мы хотим найти `(go)+`, но не хотим иметь в массиве-результате отдельным элементом содержимое скобок (`go`), то можем написать `(?:go)+`.