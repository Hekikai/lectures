Теневой DOM («Shadow DOM») используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.

**Встроенный теневой DOM**

Как устроен и стилизован сложный браузерный элемент управления? например:

```html
<input type="range"/>
```


Браузер рисует их своими силами и по своему усмотрению. Их DOM-структура обычно нам не видна, но в инструментах разработчика можно её посмотреть. К примеру, в Chrome для этого нужно активировать пункт «Show user agent shadow DOM».

После этого `<input type="range">` выглядит так:
![[Pasted image 20220330083128.png]]

То, что находится под `#shadow-root` – и называется «shadow DOM» (теневой DOM).

Мы не можем получить доступ к теневому DOM встроенных элементов с помощью обычных JavaScript-вызовов или с помощью селекторов. Это не просто обычные потомки, это мощное средство инкапсуляции.

В примере выше можно увидеть полезный атрибут `pseudo`. Он нестандартный и существует по историческим причинам. С его помощью можно стилизовать подэлементы через CSS, например, так:

```css
input::-webkit-slider-runnable-track {
	/* стили */
}
```

**Теневое дерево**

Каждый DOM-элемент может иметь 2 типа поддеревьев DOM:

1. Light tree - обычное "светлое" DOM-поддерево. Все поддеревья, о которых говорилось ранее и вообще, были светлыми.
2. Shadow tree - скрытое, «теневое», DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз.

Если у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево. Также мы всё же можем задать «композицию» теневого и обычного деревьев.

Теневое дерево можно использовать в пользовательских элементах (Custom Elements), чтобы спрятать внутренности компонента и применить к ним локальные стили.

Например, этот `<show-hello>` элемент прячет свой внутренний DOM в теневом дереве:

```html
<script>
customElements.define('show-hello', class extends HTMLElement { 

	connectedCallback() { 
		const shadow = this.attachShadow({mode: 'open'}); 
		shadow.innerHTML = `<p> 
			Hello, ${this.getAttribute('name')} 
		</p>`; 
	} 
});
</script>
```

Итак, вызов `elem.attachShadow({mode: …})` создаёт теневое дерево.

Есть два ограничения:

1. Для каждого элемента мы можем создать только один shadow root.
2. В качестве `elem` может быть использован пользовательский элемент (Custom Element), либо один из следующих элементов: «article», «aside», «blockquote», «body», «div», «footer», «h1…h6», «header», «main», «nav», «p», «section» или «span». Остальные, например, `<img>`, не могут содержать теневое дерево.

Свойство `mode` задаёт уровень инкапсуляции. У него может быть только два значения:

-   `"open"` – корень теневого дерева («shadow root») доступен как `elem.shadowRoot`.
    
    Любой код может получить теневое дерево `elem`.
    
-   `"closed"` – `elem.shadowRoot` всегда возвращает `null`.
    
    До теневого DOM в таком случае мы сможем добраться только по ссылке, которую возвращает `attachShadow` (и, скорее всего, она будет спрятана внутри класса). Встроенные браузерные теневые деревья, такие как у `<input type="range">`, закрыты. До них не добраться.

**Инкапсуляция**

Теневой DOM отделён от главного документа:

1. Элементы теневого DOM не видны из обычного DOM через `querySelector`. В частности, элементы теневого DOM могут иметь такие же идентификаторы, как у элементов в обычном DOM (light DOM). Они должны быть уникальными только внутри теневого дерева.
2. У теневого DOM свои стили. Стили из внешнего DOM не применятся.

1.  Стили главного документа не влияют на теневое дерево.
2.  …Но свои внутренние стили работают.
3.  Чтобы добраться до элементов в теневом дереве, нам нужно искать их изнутри самого дерева.