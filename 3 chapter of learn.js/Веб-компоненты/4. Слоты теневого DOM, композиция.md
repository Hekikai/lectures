Многим типам компонентов, таким как вкладки, меню, галереи изображений и другие, нужно какое-то содержимое для отображения.

Так же, как встроенный в браузер `<select>` ожидает получить контент пунктов `<option>`, компонент `<custom-tabs>` может ожидать, что будет передано фактическое содержимое вкладок, а `<custom-menu>` – пунктов меню.

Код, использующий меню `<custom-menu>`, может выглядеть так:

```html
<custom-menu> 
	<title>Сладости</title> 
	<item>Леденцы</item> 
	<item>Фруктовые тосты</item> 
	<item>Кексы</item> 
</custom-menu>
```

…Затем компонент должен правильно его отобразить – как обычное меню с заданным названием и пунктами, обрабатывать события меню и т.д.

Как это реализовать?

Можно попробовать проанализировать содержимое элемента и динамически скопировать и переставить DOM-узлы. Это возможно, но если мы будем перемещать элементы в теневой DOM, CSS-стили документа не будут применяться, и мы потеряем визуальное оформление. Кроме того, нужно будет писать дополнительный код.

К счастью, нам этого делать не нужно. Теневой DOM поддерживает элементы `<slot>`, которые автоматически наполняются контентом из обычного, «светлого» DOM-дерева.

**Именованные слоты**

Давайте рассмотрим работу слотов на простом примере.

Теневой DOM `<user-card>` имеет два слота, заполняемых из обычного DOM:

```html
<script>
customElements.define('user-card', class extends HTMLElement { 
	connectedCallback() { 
		this.attachShadow({mode: 'open'}); 
		this.shadowRoot.innerHTML = ` 
			<div>Имя:
				<slot name="username"></slot>
			</div> 
			<div>Дата рождения: 
				<slot name="birthday"></slot>
			</div> 
		`; 
	} 
}); 

</script> 
<user-card> 
	<span slot="username"_>Иван Иванов</span>
	<span slot="birthday"_>01.01.2001</span>
</user-card>
```

В теневом DOM `<slot name="X">` определяет «точку вставки» – место, где отображаются элементы с `slot="X"`.

Затем браузер выполняет «композицию»: берёт элементы из обычного DOM-дерева и отображает их в соответствующих слотах теневого DOM-дерева. В результате мы получаем именно то, что хотели – компонент, который можно наполнить данными.

Так что развёрнутый DOM составляется из теневого вставкой в слоты. Браузер использует его для рендеринга и при всплытии событий (об этом позже). Но JavaScript видит документ «как есть» – до построения развёрнутого DOM-дерева.

**Содержимое слота по умолчанию**

Если мы добавляем данные в `<slot>`, это становится содержимым «по умолчанию». Браузер отображает его, если в светлом DOM-дереве отсутствуют данные для заполнения слота.

Например, в этой части теневого дерева текст `Аноним` отображается, если в светлом дереве нет значения `slot="username"`.

```html
<div>Имя: 
	<slot name="username">Аноним</slot> 
</div>
```

**Содержимое по умолчанию (первый без имени)**

Первый `<slot>` в теневом дереве без атрибута `name` является слотом по умолчанию. Он будет отображать данные со всех узлов светлого дерева, не добавленные в другие слоты

Например, давайте добавим слот по умолчанию в наш элемент `<user-card>`; он будет собирать всю информацию о пользователе, не занесённую в другие слоты. То есть отобразит ВСЮ другую информацию в `<slot></slot>`, которая не попала в именованный слот.

**Обновление слотов**

Что если внешний код хочет динамически добавить или удалить пункты меню?

**Браузер наблюдает за слотами и обновляет отображение при добавлении и удалении элементов в слотах.**

Также, поскольку узлы светлого DOM-дерева не копируются, а только отображаются в слотах, изменения внутри них сразу же становятся видны.

Таким образом, нам ничего не нужно делать для обновления отображения. Но если код компонента хочет узнать об изменениях в слотах, можно использовать событие `slotchange`.

**API слотов**

И, наконец, давайте поговорим о методах JavaScript, связанных со слотами.

Как мы видели раньше, JavaScript смотрит на «реальный», а не на развёрнутый DOM. Но если у теневого дерева стоит `{mode: 'open'}`, то мы можем выяснить, какие элементы находятся в слоте, и, наоборот, определить слот по элементу, который в нём находится:

-  `node.assignedSlot` – возвращает элемент `<slot>`, в котором находится `node`.
-  `slot.assignedNodes({flatten: true/false})` – DOM-узлы, которые находятся в слоте. Опция `flatten` имеет значение по умолчанию `false`. Если явно изменить значение на `true`, она просматривает развёрнутый DOM глубже и возвращает вложенные слоты, если есть вложенные компоненты, и резервный контент, если в слоте нет узлов.
-  `slot.assignedElements({flatten: true/false})` – DOM-элементы, которые находятся в слоте (то же самое, что выше, но только узлы-элементы).