В компонентной архитектуре ничего не нового: мы бьем сложное на простое, чтобы можно было переиспользовать и легче поддерживать с точки зрения программистского восприятия.

Таким подходом пользуются различные FE фреймворки: Vue, React, Angular, Svelte, Preact и т.д.

Это настолько уже стало основой, как тот же ООП. Но как и в случае последнего, первый не лишён своих проблем: работа с DOM (а она является довольно трудоёмкой), инкапсуляция стилей (либо же нужно иметь филологическое образование, чтобы генерировать из себя синонимы для названия классов), поддержка кроссбраузерности.

Познакомимся с веб-компонентами поближе.

**Пользовательские элементы**

Мы можем расширять словарик HTML-элементов, создавая кастомные теги! 

Они деляется на два вида:
1.  *Автономные пользовательские элементы* – «полностью новые» элементы, расширяющие абстрактный класс `HTMLElement`.
2.  *Пользовательские встроенные элементы* – элементы, расширяющие встроенные, например кнопку `HTMLButtonElement` и т.п.

Чтобы создать пользовательский элемент, нам нужно сообщить браузеру ряд деталей о нём: как его показать, что делать, когда элемент добавляется или удаляется со страницы и т.д.

Очевидно, что это делается созданием класса, который экстендит наш основной абстрактный. А также он должен содержать некоторые методы, и все они не являются обязательными.

```js
class MyElement extends HTMLElement { 
	constructor() {
		super(); 
		// элемент создан 
	} 

	connectedCallback() { 
		// браузер вызывает этот метод при добавлении элемента в документ
		// (может вызываться много раз, если элемент многократно добавляется/удаляется) 
	} 

	disconnectedCallback() { 
		// браузер вызывает этот метод при удалении элемента из документа 
		// (может вызываться много раз, если элемент многократно добавляется/удаляется)
	} 

	static get observedAttributes() { 
		return [/* массив имён атрибутов для отслеживания их изменений */]; 
	} 

	attributeChangedCallback(name, oldValue, newValue) { 
		// вызывается при изменении одного из перечисленных выше атрибутов
	} 

	adoptedCallback() { 
		// вызывается, когда элемент перемещается в новый документ 
		// (происходит в document.adoptNode, используется очень редко)
	} 
		// у элемента могут быть ещё другие методы и свойства
}
```

После сего нам нужно зарегестрировать элемент:

```js
// сообщим браузеру, что <my-element> обслуживается нашим новым классом 
customElements.define("my-element", MyElement);
```

Теперь для любых HTML-элементов с тегом `<my-element>` создаётся экземпляр `MyElement` и вызываются вышеупомянутые методы. Также мы можем использовать `document.createElement('my-element')` в JavaScript.

Имя пользовательского элемента должно содержать дефис! Чтобы гаранитровать отсутствие конфликтов имён между встроенными и пользовательскими элементами.

Рендеринг происходит в `connectedCallback`, а не в `constructor`. Причина проста: когда вызывается `constructor`, делать это слишком рано. Экземпляр элемента создан, но на этом этапе браузер ещё не обработал/назначил атрибуты: вызовы `getAttribute` вернули бы `null`. Так что мы не можем рендерить здесь.

**Порядок рендеринга**

Когда HTML-парсер строит DOM, элементы обрабатываются друг за другом, родители - потом дети. 

Например, если пользовательский элемент пытается получить доступ к `innerHTML` в `connectedCallback`, он ничего не получает:

```html
<script> 
customElements.define('user-info', class extends HTMLElement { 

	connectedCallback() { 
		alert(this.innerHTML); // пусто (*) 
	} 
}); 
</script>

<user-info>Джон</user-info>
```

Это происходит именно потому, что на этой стадии ещё не существуют дочерние элементы, DOM не завершён. HTML-парсер подключил пользовательский элемент `<user-info>` и теперь собирается перейти к его дочерним элементам, но пока не сделал этого.

Если мы хотим передать информацию в пользовательский элемент, мы можем использовать атрибуты. Они доступны сразу.

Или, если нам действительно нужны дочерние элементы, мы можем отложить доступ к ним, используя `setTimeout` с нулевой задержкой.

Решение с setTimeout не идеально, так как дети этого элемента тоже могут быть с setTimeout, тогда первым придет сообщение родителя, а потом уже дети в прямом порядке.

Так что тут поможет лишь слушать событие :)

**Модифицированные встроенные элементы**

Новые элементы, которые мы создаём, такие как `<time-formatted>`, не имеют связанной с ними семантики. Они не известны поисковым системам, а устройства для людей с ограниченными возможностями не могут справиться с ними.

Но такие вещи могут быть важны. Например, поисковой системе было бы интересно узнать, что мы показываем именно время. А если мы делаем специальный вид кнопки, почему не использовать существующую функциональность `<button>`?

Мы можем расширять и модифицировать встроенные HTML-элементы, наследуя их классы.

Например, кнопки `<button>` являются экземплярами класса `HTMLButtonElement`, давайте построим элемент на его основе.

1. Наследуем `HTMLButtonElement` нашим классом:

```js
class HelloButton extends HTMLButtonElement {
	/* методы пользовательского элемента */
}
```

2. Предоставим третий аргумент в `customElements.define`, указывающий тег:

```js
customElements.define('hello-button', HelloButton, {extends: 'button'});
```

Бывает, что разные теги имеют одинаковый DOM-класс, поэтому указание тега необходимо.

3. В конце, чтобы использовать наш пользовательский элемент, вставим обычный тег `<button>`, но добавим к нему `is="hello-button"`:

```js
<button is="hello-button">...</button>
```

Теперь мы можем использовать его в разметке!