Куки - небольшие строки данных, которые хранятся непосредственно в браузере. Куки устанавливаются веб-сервером с помощью заголовка `Set-Cookie`. 

Наиболее распространённый метод использования куки - это аутентификация.
1. При входе на сайт сервер отсылает HTTP-заголовок `Set-Cookie` для того, чтобы установить куки со специальным уникальным идентификатором сессии ("session identifier").
2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок `Cookie`.
3. Таким образом, сервер понимает, кто сделал запрос.

**Чтение из document.cookie**

Почти на каждом сайте можно прочитать куки. Делается это с помощью команды `document.cookie`. Данные представлены в виде ключ=значение, разделенные `;`. Эти данные можно как засплитить по `;`, так и распарсить с помощью регулярных выражений.

**Запись в document.cookie**

**Запись в `document.cookie` обновит только упомянутые в ней куки, но при этом не затронет все остальные.**

Поэтому в куки можно спокойно записать `user=Artem`, а все остальные куки останутся.

Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию `encodeURIComponent`:
```js
// специальные символы (пробелы), требуется кодирование 
let name = "my name";
let value = "John Smith"

// кодирует в my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
```

Ограничения:
1. После `encodeURIComponent` пара `name=value` не должна занимать более 4Кб. Таким образом, мы не можем хранить в куки большие данные.
2. Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.

У куки есть ряд настроек, многие из которых важны и должны быть установлены.

Эти настройки указываются после пары `ключ=значение` и отделены друг от друга разделителем `;`, вот так:
```js
document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"
```

**path**

-   **`path=/mypath`**

URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.

Если куки установлено с `path=/admin`, то оно будет доступно на страницах `/admin` и `/admin/something`, но не на страницах `/home` или `/adminpage`.

Как правило, указывают в качестве пути корень `path=/`, чтобы наше куки было доступно на всех страницах сайта.

**domain**

-   **`domain=site.com`**

Домен, на котором доступны наши куки. На практике, однако, есть ограничения – мы не можем указать здесь какой угодно домен.

По умолчанию куки доступно лишь тому домену, который его установил. Так что куки, которые были установлены сайтом `site.com`, не будут доступны на сайте `other.com`.

Но и в таком случае мы не сможем получить доступ к данным на `forum.site.com`! 

**Нет способа сделать куки доступным на другом домене 2-го уровня, так что `other.com` никогда не получит куки, установленное сайтом `site.com`.**

Это ограничение безопасности, чтобы мы могли хранить в куки конфиденциальные данные, предназначенные только для одного сайта.

…Однако, если мы всё же хотим дать поддоменам типа `forum.site.com` доступ к куки, это можно сделать. Достаточно при установке куки на сайте `site.com` в качестве значения опции `domain` указать корневой домен: `domain=site.com`:
```js
// находясь на странице site.com 
// сделаем куки доступным для всех поддоменов *.site.com: 
document.cookie = "user=John; domain=site.com"

// позже

// на forum.site.com 
alert(document.cookie); // есть куки user=John
```

По историческим причинам установка `domain=.site.com` (с точкой перед `site.com`) также работает и разрешает доступ к куки для поддоменов. Это старая запись, но можно использовать и её, если нужно, чтобы поддерживались очень старые браузеры.

Таким образом, опция `domain` позволяет нам разрешить доступ к куки для поддоменов.

**expires, max-age**

Эти два параметра позволяют задать максимально время жизни куки. А также помогут куки "пережить" закрытие браузера!

Для этого нужно установить `expires` в `true`, указав после дату в GMT. Мы можем использовать `date.toUTCString`, чтобы получить правильную дату. Например, мы можем установить срок действия куки на 1 день.
```js
// +1 день от текущей даты
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=John; expires=" + date;
```

Если мы установим в `expires` прошедшую дату, то куки будет удалено.

А что насчет `max-age`? Это альтернатива `expires`, которая устанавливает время жизни куки в секундах с момента установления; если задан ноль или отрицательное значение, то куки будет удалено:
```js
// куки будет удалено через 1 час 
document.cookie = "user=John; max-age=3600";

// удалим куки (срок действия истекает прямо сейчас) 
document.cookie = "user=John; max-age=0";
```

**secure**

Куки не обращают внимания на протокол, так что если куки установлены на `http://site.com`, то они будут доступны и на `https://site.com` и наоборот.


С этой настройкой, если куки будет установлено на сайте `https://site.com`, то оно не будет доступно на том же сайте с протоколом HTTP, как `http://site.com`. Таким образом, если в куки хранится конфиденциальная информация, которую не следует передавать по незашифрованному протоколу HTTP, то нужно установить этот флаг.
```js
// предполагается, что сейчас мы на https:// 
// установим опцию secure для куки (куки доступно только через HTTPS) 
document.cookie = "user=John; secure";
```

**samesite**

Это ещё одна настройка безопасности, применяется для защиты от так называемой XSRF-атаки (межсайтовая подделка запроса).

Чтобы понять, как настройка работает и где может быть полезной, посмотрим на XSRF-атаки.

**Атака XSRF**

Представим, что мы авторизовались на `bank.com`. При каждом действии браузер посылает запрос на сервер вместе с куки, чтобы тот понимал, что он может ответить нам разрешением на выполнение действия. Но что если в другом окне мы переходим на сайт `evil.com`, который автоматически отправляет форму `<form action="https://bank.com/pay"` на сайт `bank.com` с заполненными полями, которые инициируют транзакцию на счёт хакера.

Браузер посылает куки при каждом посещении `bank.com`, даже если форма была отправлена с `evil.com`. Таким образом, банк узнает вас и выполнит платёж.

Такая атака называется межсайтовая подделка запроса (или Cross-Site Request Forgery, XSRF).

И чтобы защититься от неё, там нужен xsrf-токен, который генерирует каждое поле формы.

**Настройка samesite**

Параметр куки `samesite` предоставляет ещё один способ защиты от таких атак, который (теоретически) не должен требовать «токенов защиты xsrf».
Данный параметр блокирует отправку куки, если отправка была не с того же адреса. 
У него есть два возможных значения:

-   `samesite=strict` (или, что то же самое, `samesite` без значения)

Если куки имеют настройку `samesite`, то атака XSRF не имеет шансов на успех, потому что отправка с сайта `evil.com` происходит без куки. Таким образом, сайт `bank.com` не распознает пользователя и не произведёт платёж.

Защита довольно надёжная. Куки с настройкой `samesite` будет отправлено только в том случае, если операции происходят с сайта `bank.com`, например отправка формы сделана со страницы на `bank.com`.

Хотя есть небольшие неудобства.

Когда пользователь перейдёт по ссылке на `bank.com`, например из своих заметок, он будет удивлён, что сайт `bank.com` не узнал его. Действительно, куки с `samesite=strict` в этом случае не отправляется.

Мы могли бы обойти это ограничение, используя два куки: одно куки для «общего узнавания», только для того, чтобы поздороваться: «Привет, Джон», и другое куки для операций изменения данных с `samesite=strict`. Тогда пользователь, пришедший на сайт, увидит приветствие, но платежи нужно инициировать с сайта банка, чтобы отправилось второе куки.

-   **`samesite=lax`**

Это более мягкий вариант, который также защищает от XSRF и при этом не портит впечатление от использования сайта.

Режим Lax так же, как и `strict`, запрещает браузеру отправлять куки, когда запрос происходит не с сайта, но добавляет одно исключение.

Куки с `samesite=lax` отправляется, если два этих условия верны:

1. Используются безопасные HTTP-методы (например, GET, но не POST).

Полный список безопасных HTTP-методов можно посмотреть в спецификации [RFC7231](https://tools.ietf.org/html/rfc7231). По сути, безопасными считаются методы, которые обычно используются для чтения, но не для записи данных. Они не должны выполнять никаких операций на изменение данных. Переход по ссылке является всегда GET-методом, то есть безопасным.

2. Операция осуществляет навигацию верхнего уровня (изменяет URL в адресной строке браузера).

Таким образом, режим `samesite=lax`, позволяет самой распространённой операции «переход по ссылке» передавать куки. Например, открытие сайта из заметок удовлетворяет этим условиям.

Но что-то более сложное, например, сетевой запрос с другого сайта или отправка формы, теряет куки.

Если это вам походит, то добавление `samesite=lax`, скорее всего, не испортит впечатление пользователей от работы с сайтом и добавит защиту.

В целом, `samesite` отличная настройка, но у неё есть важный недостаток:

-   `samesite` игнорируется (не поддерживается) старыми браузерами, выпущенными до 2017 года и ранее.

**Так что, если мы будем полагаться исключительно на `samesite`, то старые браузеры будут уязвимы.**

Но мы, безусловно, можем использовать `samesite` вместе с другими методами защиты, такими как XSRF-токены, чтобы добавить дополнительный слой защиты, а затем, в будущем, когда старые браузеры полностью исчезнут, мы, вероятно, сможем полностью удалить XSRF-токены.

**httpOnly**

Веб-сервер использует заголовок `Set-Cookie` для установки куки. И он может установить настройку `httpOnly`.

Эта настройка позволяет полностью отключить доступ к куки с помощью JavaScript. Мы не можем видеть такое куки или манипулировать им с помощью `document.cookie`.