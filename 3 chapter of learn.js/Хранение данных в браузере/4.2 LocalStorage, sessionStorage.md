Это объекты веб-хранилища, которые позволяют хранить данные в виде пары ключ/значение в браузере.

`localStorage` позволяет хранить данные даже после закрытия браузера, а `sessionStorage` только после обновления страницы.

Но есть одна деталь: у нас же есть куки ([[4.1 Куки, document.cookie]]), зачем нам эти объекты?

-   В отличие от куки, объекты веб-хранилища *не отправляются на сервер при каждом запросе*. Поэтому мы можем хранить гораздо больше данных. Большинство браузеров могут сохранить как минимум 2 мегабайта данных (или больше), и этот размер можно поменять в настройках.
-   Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
-   Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

Объекты хранилища `localStorage` и `sessionStorage` предоставляют одинаковые методы и свойства:
-   `setItem(key, value)` – сохранить пару ключ/значение.
-   `getItem(key)` – получить данные по ключу `key`.
-   `removeItem(key)` – удалить данные с ключом `key`.
-   `clear()` – удалить всё.
-   `key(index)` – получить ключ на заданной позиции.
-   `length` – количество элементов в хранилище.

Как видим, интерфейс похож на `Map` (`setItem/getItem/removeItem`), но также запоминается порядок элементов, и можно получить доступ к элементу по индексу – `key(index)`.

**Особенности localStorage**

Основные особенности `localStorage`:

-   Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
-   Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.

Если где-нибудь на сайте установить в локалку значение, то на другой вкладке этого же сайта будет доступ к этому значению! Нам достаточно находиться на том же источнике (домен/протокол/порт), при этом URL-путь может быть разным.

**Доступ как к обычному объекту**

Также можно получать/записывать данные, как в обычный объект:
```js
// установить значение для ключа 
localStorage.test = 2;

// получить значение по ключу 
console.log( localStorage.test ); // 2

// удалить ключ 
delete localStorage.test;
```

Это возможно по историческим причинам и, как правило, работает, но обычно не рекомендуется, потому что:

1.  Если ключ генерируется пользователем, то он может быть каким угодно, включая `length` или `toString` или другой встроенный метод `localStorage`. В этом случае `getItem/setItem` сработают нормально, а вот чтение/запись как свойства объекта не пройдут:
```js
const key = 'length';
localStorage[key] = 5; // Ошибка, невозможно установить length
```

2. Когда мы модифицируем данные, то срабатывает событие `storage`. Но это событие не происходит при записи без `setItem`, как свойства объекта. Мы увидим это позже.

**Перебор ключей**

Методы, которые мы видим, позволяют читать/писать/удалять данные. А как получить все значения или ключи?

К сожалению, объекты веб-хранилища нельзя перебрать в цикле, они не итерируемы.

Но можно пройти по ним, как по обычным массивам:
```js
for(let i = 0; i < localStorage.length; i++) {
	const ket = localStorage.key(i);
	console.log(`${key}: ${localStorage.getItem(key)}`);
}
```

Другой способ – использовать цикл, как по обычному объекту `for key in localStorage`.

Здесь перебираются ключи, но вместе с этим выводятся несколько встроенных полей, которые нам не нужны.

…Поэтому нам нужно либо отфильтровать поля из прототипа проверкой `hasOwnProperty`:
```js
for(let key in localStorage) { 
	if (!localStorage.hasOwnProperty(key)) {
		continue; // пропустит такие ключи, как "setItem", "getItem" и так далее 
	}
	console.log(`${key}: ${localStorage.getItem(key)}`); 
}
```

…Либо просто получить «собственные» ключи с помощью Object.keys, а затем при необходимости вывести их при помощи цикла. Это работает, так как `Object.keys` возвращает только ключи, принадлежащие объекту, игнорируя прототип. 

**Только строки**

Обратите внимание, что ключ и значение должны быть строками.

Если мы используем любой другой тип, например число или объект, то он автоматически преобразуется в строку:
```js
sessionStorage.user = {name: "John"};
alert(sessionStorage.user); // [object Object]
```

Мы можем использовать `JSON` для хранения объектов:
```js
sessionStorage.user = JSON.stringify({name: "John"}); 

// немного позже 
let user = JSON.parse( sessionStorage.user ); 
alert( user.name ); // John
```

Также возможно привести к строке весь объект хранилища, например для отладки:
```js
// для JSON.stringify добавлены параметры форматирования, чтобы объект выглядел лучше 
alert( JSON.stringify(localStorage, null, 2) );
```

**sessionStorage**

Объект `sessionStorage` используется гораздо реже, чем `localStorage`.

Свойства и методы такие же, но есть существенные ограничения:

-   `sessionStorage` существует только в рамках текущей вкладки браузера.
    -   Другая вкладка с той же страницей будет иметь другое хранилище.
    -   Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
-   Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

Так получилось, потому что `sessionStorage` привязан не только к источнику, но и к вкладке браузера. Поэтому `sessionStorage` используется нечасто.

**Событие storage**

Когда обновляются данные в `localStorage` или `sessionStorage`, генерируется событие [storage](https://html.spec.whatwg.org/multipage/webstorage.html#the-storageevent-interface) со следующими свойствами:

-   `key` – ключ, который обновился (`null`, если вызван `.clear()`).
-   `oldValue` – старое значение (`null`, если ключ добавлен впервые).
-   `newValue` – новое значение (`null`, если ключ был удалён).
-   `url` – url документа, где произошло обновление.
-   `storageArea` – объект `localStorage` или `sessionStorage`, где произошло обновление.

Важно: событие срабатывает на всех остальных объектах `window`, где доступно хранилище, кроме того окна, которое его вызвало.

Давайте уточним.

Представьте, что у вас есть два окна с одним и тем же сайтом. Хранилище `localStorage` разделяется между ними.

Вы можете открыть эту страницу в двух окнах браузера, чтобы проверить приведённый ниже код.

Теперь, если оба окна слушают `window.onstorage`, то каждое из них будет реагировать на обновления, произошедшие в другом окне.

Также `event.storageArea` содержит объект хранилища – событие одно и то же для `sessionStorage` и `localStorage`, поэтому `event.storageArea` ссылается на то хранилище, которое было изменено. Мы можем захотеть что-то записать в ответ на изменения.