1. *Position. Что это такое, отличие между значениями*

Position - это css-свойство, которое отвечает за позицию элемента на экране или в DOM-дереве.
Значения: static, relative, absolute, fixed.

Static - это неспозиционированный элемент, т. е. значение по умолчанию.

Relative - это относительно спозиционированный элемент. Позиционируется относительно своего же позиции. Позиционируется с помощью указания координат `top/right/bottom/left`.

Absolute - это абсолютно спозиционированный элемент. Позиционируется относительно ближайшего не static-элемента с помощью `top/right/bottom/left`. Отличие от relative - он "исчезает из общего потока" (где все элементы) и позиционируется, а это означает, что другие элементы его не видят и двигаются на его место (в отличие от relative). Ширина элемента устанавливается по содержимому. А также ставится display: block.

Fixed - фиксируется относительно экрана (window).

Sticky - почитать и потыкать.

2. *Display. Что это такое, отличие между значениями*

Display - это css-свойство, которое определяет тип отображения элемента.
Значения: none, block, inline, inline-block, flex, grid.

None - элемент с этим значением дисплея пропадает с экрана (и для скринридеров тоже), но все ещё находится в DOM.

Block - это блочный элемент. Основные характеристики блочного элемента:
- занимает всю ширину экрана 
- можно задать width и height

Inline - это инлайновый элемент. Основные характеристики инлайнового элемента:
- контент определяет ширину и высоту элемента (явно поменять width и height нельзя)
- располагается друг с другом в отличие от блочных (которые располагаются друг под другом)

Inline-block - это блочно-строчный элемент. Он имеет совместные свойства:
- располагаются друг с другом, но можно задать высоту и ширину 
- контент определяет width и height

3. *Flex, grid*

Flex - свойство, которое позволяет применить flexbox-layout для быстрого построения сложных, гибких макетов, которые в традиционных методах CSS создать довольно труднозатратно. 

Набор свойств: flex-direction, flex-wrap, align-items, justify-content, align-self (для переопределения align-items у элементов), order.  

Grid - свойство, которое представляет двумерную сетку для CSS. То есть это пересекающийся набор горизонтальных и вертикальных линий. 

Набор свойств: grid-template-columns, grid-template-rows, fr (единица измерения), minmax(100px, auto) для grid-auto-rows, grid-gap (зазорычи), grid-tamplate-columns: subgrid (для вложенных гридов, чтобы они использовали родительские настройки размещения).

4. *Keyframes, media*

Связано со свойством animation, которое позволяет задать настройки для анимации, связав с @keyframes.

@keyframes <my_animation_name> {
	0%:   {}
	50%:  {}
	100%: {}
}

Медиа-запросы нужны для того, чтобы писать респонсив разметку (особенно для мобильных устройств).

@media (max-width: 500px) {
	/your css-propeties/
}

// Height < width 
@media (orientation: landscape) {
	/your css-propeties/
}

// Width < height
@media (orientation: portrait) {
	/your css-propeties/
}

@media <type_of_device> and (max-width: 500px) {
	/your css-propeties/

}

@media print {
	/your css-propeties/

}

5. *CSS variables и как менять их из JS*

CSS-переменные начинаются с двойного тире: --propertie: значение.
Чтобы использовать их дальше в таблице каскадных стилей, нужно писать значение свойства у элемента, а далее использовать var(--propetie).

Например:

```css
:root {  
    --div-background-color: red;  
    --text-color: black;  
    --div-padding: 10px;  
    --div-margin: 10px;  
}  
  
.child {  
    background-color: var(--div-background-color);  
}
```

Чтобы поменять их из JS, нужно обратиться либо к document.documentElement.style.<нужное_своство>.setProperty('<название_css_переменной>', <значение>);

6. *CSS SCSS (писать на проектике)*

SASS - CSS-препроцессор, который позволяет писать удобный CSS-код, используя различные плюшки.
И эти самые плюшки: 
- вложенность; 
- переменные (через знак $);
- импорт (например, стили обнуления - @import "nullstyle.scss");
- шаблоны (через знак %, а использование шаблона - @extend <название_шаблона>);
- миксины (через @mixin <название_миксина>(параметр) { ...properties }, а использование через @include <название_миксина>(аргумент) );
- математические операторы;
- удобные комментарии.

7. *vh/em/rem/vw/vmin/vmax*

Это единицы измерения, которые позволяют создавать "резиновую верстку". 
- vh - viewport hight - 1% высоты экрана;
- vw - viewport width - 1% ширины экрана;
- vmin/vmax - принимают два аргумента (vw, vh) - и возвращают минимальное или максимальное значение соотвественно.
- em - emphemeral unit - позволяет считывать размер шрифта родителя и изменять его в пропорции, которая задана. У родителя - 24px, у ребёнка 1.5em = 36px;
- rem - root emphemeral unit - берется из корневого элемента ( размер шрифта, указанный в `<html>` )

8. *Блочные, строчные, блочно-строчные элементы. Схлопывание марджинов без флекса и с ним*

У блочных элементов все нормально с паддингами и марджинами. 
Строчные элементы не знают про margin, но по бокам отступ сработает, с padding возникают проблемы. Чтобы работали margin, padding - нужно поставить inline-block, либо block.

Схлопывание margin'ов - это случай, когда есть, например, `margin-bottom: 20px` у элемента сверху, а у элемента снизу - `margin-top:40px`. Общий margin опрередляется по БОЛЬШЕМУ из margin.


9. *Селекторы различные*

 - `*`, .class, #id, div
 -  > (все непосредственные потомки);
 -  ~ - все соседи на том же уровне вложенности;
 -  + - первый правый сосед;
 -  [attr="value"] - селектор на аттрибут;
 -  :focus - селектор на псевдокласс;
 -  :first-child, :last-child - первый и последний потомок родителя; 
 -  :nth-child(a) - потомки номер `a` родителя; 
 -  ::after, ::before - псевдоэлементы после или перед родителем.

10. *Специфичность, important, css vs style, important css vs style, important vs important in style*

**Специфичность** представляет собой вес, который придается конкретному правилу CSS.

Вес правила определяется **количеством каждого из типов селекторов в данном правиле**. Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS. Специфичность имеет значение только в том случае, если один элемент соответствует нескольким правилам.

Согласно спецификации CSS, правило для [непосредственно соответствующего элемента](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity#directly-targeted-elements) всегда будет иметь больший приоритет, чем правила, унаследованные от предка.

Декларация !important - это ключевое слово, которое может быть добавлено в конце любой пары ключ/значение.

Например:

```css
p {
	padding: 10px !important;
}
```

Иногда необходимо поменять приоритет правил. Разорвать цепочку каскада можно с помощью декларации !important. В случае её использования, отмеченное правило будет иметь самый высокий "вес" и именно оно будет использоваться.

Переопределить в JS:

```js
function myFunction() {
    const value = document.querySelectorAll("#testDiv p.example");
    value[0].style.setProperty("background-color", "red", "important");
}
```

Инлайн стили писать не очень удобно, да и специфичность нарушается (применяется всегда инлайн-стиль, даже если есть что-то в .css файле).

!important css-стиля перекрывает инлайн стиль элемента.

!important инлайнового стиля перекрывает !important css-стиля.
