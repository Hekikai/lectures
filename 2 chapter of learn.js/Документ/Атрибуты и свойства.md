Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты. **Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.**

Но преобразование атрибута в свойство происходит не один-в-один!

DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:

-   Им можно присвоить любое значение.
-   Они регистрозависимы (нужно писать `elem.nodeType`, не `elem.NoDeTyPe`).

**HTML-атрибуты**

В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт _стандартные_ атрибуты и создаёт DOM-свойства для них.

Таким образом, когда у элемента есть `id` или другой _стандартный_ атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный.

Пожалуйста, учтите, что стандартный атрибут для одного тега может быть нестандартным для другого. Например, атрибут `"type"` является стандартным для элемента `<input>` ([HTMLInputElement](https://html.spec.whatwg.org/#htmlinputelement)), но не является стандартным для `<body>` ([HTMLBodyElement](https://html.spec.whatwg.org/#htmlbodyelement)). Стандартные атрибуты описаны в спецификации для соответствующего класса элемента.

Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?

Конечно. Все атрибуты доступны с помощью следующих методов:

-   `elem.hasAttribute(name)` – проверяет наличие атрибута.
-   `elem.getAttribute(name)` – получает значение атрибута.
-   `elem.setAttribute(name, value)` – устанавливает значение атрибута.
-   `elem.removeAttribute(name)` – удаляет атрибут.

У HTML-атрибутов есть следующие особенности:

-   Их имена регистронезависимы (`id` то же самое, что и `ID`).
-   Их значения всегда являются строками.

Пожалуйста, обратите внимание:

1.  `getAttribute('About')` – здесь первая буква заглавная, а в HTML – строчная. Но это не важно: имена атрибутов регистронезависимы.
2.  Мы можем присвоить что угодно атрибуту, но это станет строкой. Поэтому в этой строчке мы получаем значение `"123"`.
3.  Все атрибуты, в том числе те, которые мы установили, видны в `outerHTML`.
4.  Коллекция `attributes` является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные) в виде объектов со свойствами `name` и `value`.\

**Синхронизация между атрибутами и свойствами**

Не всё работает в две стороны. Да, иногда измненение свойства влечет за собой измненение атрибута, но так случается не всегда.
Тому пример `input.value`. Если менять свойство в коде, то в атрибуте оно не изменится! Как это было бы с другим, например, свойстом (id, например).

**DOM-свойства типизированы**

DOM-свойства не всегда являются строками. Например, свойство `input.checked` (для чекбоксов) имеет логический тип. 

Есть и другие примеры. Атрибут `style` – строка, но свойство `style` является объектом.

Хотя большинство свойств, всё же, строки.

При этом некоторые из них, хоть и строки, могут отличаться от атрибутов. Например, DOM-свойство `href` всегда содержит _полный_ URL, даже если атрибут содержит относительный URL или просто `#hash`.

**Нестандартные атрибуты**

Чтобы вводить свои или же пользовательские атрибуты, придумали data-атрибуты.
**Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве `dataset`.**

Например, если у `elem` есть атрибут `"data-about"`, то обратиться к нему можно как `elem.dataset.about`. Атрибуты, состоящие из нескольких слов, к примеру `data-order-state`, становятся свойствами, записанными с помощью верблюжьей нотации: `dataset.orderState`. 

Использование `data-*` атрибутов – валидный, безопасный способ передачи пользовательских данных.

Пожалуйста, примите во внимание, что мы можем не только читать, но и изменять data-атрибуты. 