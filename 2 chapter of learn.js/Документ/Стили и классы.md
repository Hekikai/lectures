Как правило, существует два способа задания стилей для элемента:

1.  Создать класс в CSS и использовать его: `<div class="...">`
2.  Писать стили непосредственно в атрибуте `style`: `<div style="...">`.

Первый более предпочтительнее, а второй можно использовать, например, когда нам нужно вычислить координаты и динамически их обновить через JavaScript. 

В других случаях, например, чтобы сделать текст красным, добавить значок фона – описываем это в CSS и добавляем класс (JavaScript может это сделать). Это более гибкое и лёгкое в поддержке решение.

**className и classList**

Когда-то давно в JavaScript существовало ограничение: зарезервированное слово типа `"class"` не могло быть свойством объекта. Это ограничение сейчас отсутствует, но в то время было невозможно иметь свойство `elem.class`.

Поэтому для классов было введено схожее свойство `"className"`: `elem.className` соответствует атрибуту `"class"`.

Если мы присваиваем что-то `elem.className`, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс.

Для этого есть другое свойство: `elem.classList`.

`elem.classList` – это специальный объект с методами для добавления/удаления одного класса.
```html
<body class="main page"> 
	<script> 
		// добавление класса
		document.body.classList.add('article');
		alert(document.body.className); // main page article 
	</script> 
</body>
```

Так что мы можем работать как со строкой полного класса, используя `className`, так и с отдельными классами, используя `classList`. Выбираем тот вариант, который нам удобнее.

Методы `classList`:

-   `elem.classList.add/remove("class")` – добавить/удалить класс.
-   `elem.classList.toggle("class")` – добавить класс, если его нет, иначе удалить.
-   `elem.classList.contains("class")` – проверка наличия класса, возвращает `true/false`

Кроме того, `classList` является перебираемым, поэтому можно перечислить все классы при помощи `for..of`.

**Element style**

Можно устанавливать стили через объект `style` у тега, который мы получили в JS.
Установка стиля `elem.style.width="100px"` работает так же, как наличие в атрибуте `style` строки `width:100px`.

Для свойства из нескольких слов используется camelCase:
```html
background-color => elem.style.backgroundColor
z-index => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
```

Стили с браузерным префиксом, например, `-moz-border-radius`, `-webkit-border-radius` преобразуются по тому же принципу: дефис означает заглавную букву.

**Сброс стилей**

Иногда нам нужно добавить свойство стиля, а потом, позже, убрать его.

Например, чтобы скрыть элемент, мы можем задать `elem.style.display = "none"`.

Затем мы можем удалить свойство `style.display`, чтобы вернуться к первоначальному состоянию. Вместо `delete elem.style.display` мы должны присвоить ему пустую строку: `elem.style.display = ""`.

Для задания нескольких стилей в одной строке используется специальное свойство `style.cssText`

**Вычисленные стили: getComputedStyle**

Итак, изменить стиль очень просто. Но как его _прочитать_?

Например, мы хотим знать размер, отступы, цвет элемента. Как это сделать?

**Свойство `style` оперирует только значением атрибута `"style"`, без учёта CSS-каскада.**

Для этого есть метод: `getComputedStyle`.
```html
getComputedStyle(element, [pseudo])
```

- element

Элемент, значения для которого нужно получить

- pseudo

Указывается, если нужен стиль псевдоэлемента, например `::before`. Пустая строка или отсутствие аргумента означают сам элемент.

Результат вызова – объект со стилями, похожий на `elem.style`, но с учётом всех CSS-классов.

В настоящее время `getComputedStyle` фактически возвращает окончательное значение свойства, для геометрии оно обычно в пикселях.

Для правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderTopWidth`. При обращении к сокращённому: `padding`, `margin`, `border` – правильный результат не гарантируется.

Например, если есть свойства `paddingLeft/paddingTop`, то что мы получим вызывая `getComputedStyle(elem).padding`? Ничего, или, может быть, «сгенерированное» значение из известных внутренних отступов? Стандарта для этого нет.