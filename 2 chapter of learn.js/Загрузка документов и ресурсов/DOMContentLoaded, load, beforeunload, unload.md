Существует три важных этапа "жизни" странички в браузере и четыре нужных нам "события":
1. `DOMContentLoaded` - стадия, когда загрузился HTML и построилось DOM-дерево; внешние данные, такие как: стили, картинки, шрифты пока подгружаются.
2. `load` - загрузилась и страница, и DOM, и внешние файлы
3. `beforeunload` - пользователь покидает страницу и как раз на этом этапе можно спросить, не хочет ли пользователь остаться =)
4. `unload` - пользователь вот-вот покинет страничку; этот этап есть для того, чтобы мы могли отправить статистику, например.

Рассмотрим каждый этап более глубже.

**DOMContentLoaded**

Это событие срабатывает на документе (`document`). "Поймать" и как-то захендлить его можно с помощью `addEventListener("DOMCOntentLoaded", ...)`.

Вроде все просто: DOM-дерево готово, значит получаем событие. Но есть несколько нюансов.

**DOMContentLoaded и скрипты**

Когда браузер обрабатывает HTML-документ, то, встретив тег `script`, он должен его выполнить, а только потом продолжить строить DOM-дерево. Сделано это для того, что если наш скрипт хочет что-то сделать с документом, то он может это выполнить. Так что `DOMContentLoaded` подождет, пока выполнятся скрипты.

Исключения:
1. Скрипты с атрибутом `async` не блокируют DOMContentLoaded.
2. Скрипты, сгенерированные с помощью `document.createElement('script')` также не блокируют DOMContentLoaded.

**DOMContentLoaded и стили**

Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждет. Но есть нюанс: если после тега `link` со стилями стоит тег `script`, то скрипт будет ждать, пока загрузятся стили. Сделано это для того, чтобы скрипт мог работать со стилями из внутренного кода.

Так как `DOMContentLoaded` дожидается скриптов, то теперь он так же дожидается и стилей перед ними.

**Встроенное в браузер автозаполнение**

Если есть сохраненные логини и пароли, то при автозаполнении они могут не сразу туда добавятся. Это как раз и есть `DOMContentLoaded`.

**window.onload**

Событие `load` объекта `window` наступает только тогда, когда загрузилась и страница, и стили, и картинки, и другие ресурсы.

**window.onunload**

Когда посетитель покидает страницу, то генерируется событие `unload`. Тут не стоит делать громоздких вычислений или действий, так что обычно на этом этапе собирают и отправляют статистику о нажатиях, прокрутках, просмотрах и т.п.

Для этого существует специальный метод `navigator.sendBeacon(url, data)`, описанный в спецификации [https://w3c.github.io/beacon/](https://w3c.github.io/beacon/).

Но на этом этапе не получится отменить переход на другую страницу. Для этого есть следующий метод.

**window.onbeforeunload**

Если пользователь собирается уйти со страницы, то этот обработчки может спросить, хочет ли он этого (попросит дополнительного подтверждения).

Если мы отменим это событие, то браузер спросит посетителя, уверен ли он.

```js
window.onbeforeunload = function() {
	return false;
}
```

**readyState**

Если мы попытаемся установить обработчик `DOMContentLoaded` после того, как документ загрузился, то мы ничего не получим. Ну просто потому, что это событие уже просто не произойдет.

Так что если нам нужен определенный этап загрузки страницы (самое начало этого конспект), то у документа есть свойство `readyState`, которое показывает нам текущее состояние загрузки:
- `"loading"` - документ грузится;
- `"interactive"` - документ был полностью прочитан;
- `"complete"` - документ был полностью прочитан и все внешние ресурсы были загружены.

Также есть событие `readystatechange`, которое генерируется при изменении состояния.