Суть принципа состоит в том, чтобы добавить обработчик какого-либо события, а далее, при помощи `data-атритубов` или же css-классов реализовывать некоторое поведение. Так как при всплытии или же погружении просматривается каждый элемент вплоть до конечной инстанции (HTML или же последний элеменет body).

Так выглядит алгоритм:
1.  Вешаем обработчик на контейнер.
2.  В обработчике проверяем исходный элемент `event.target`.
3.  Если событие произошло внутри нужного нам элемента, то обрабатываем его.

Удобства:
-   Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
-   Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
-   Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения `innerHTML` и ему подобных.

Небольшие минусы:
-   Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать `event.stopPropagation()`.
-   Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.