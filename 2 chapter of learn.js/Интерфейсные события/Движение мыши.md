**События mouseover/mouseout, relatedTarget**

Событие `mouseover` происходит в момент, когда курсор оказывается над элементом, а событие `mouseout` – в момент, когда курсор уходит с элемента.

Эти события являются особенными, потому что у них имеется свойство `relatedTarget`. Оно «дополняет» `target`. Когда мышь переходит с одного элемента на другой, то один из них будет `target`, а другой `relatedTarget`.

Для события `mouseover`:

-   `event.target` – это элемент, _на который_ курсор перешёл.
-   `event.relatedTarget` – это элемент, _с которого_ курсор ушёл (`relatedTarget` → `target`).

Для события `mouseout` наоборот:

-   `event.target` – это элемент, _с которого_ курсор ушёл.
-   `event.relatedTarget` – это элемент, _на который_ курсор перешёл (`target` → `relatedTarget`).

Свойство `relatedTarget` может быть `null`. Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.

Следует держать в уме такую возможность при использовании `event.relatedTarget` в своём коде. Если, например, написать `event.relatedTarget.tagName`, то при отсутствии `event.relatedTarget` будет ошибка.

**Пропуск элементов**

Событие `mousemove` происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.

Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события `mousemove`.

Это означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены. 

**Но!**
Если было событие `mouseover`, то будет и событие `mouseout`. Раз элемент был "замечен", то он не может быть потом не "стерт" из "зрительной памяти" браузера. 

**Родитель и потомки**
У `mouseout` есть удобная особенность - оно срабатывает тогда, когда переходишь на вложенный элемент какого-нибудь родителя, хотя визуально можешь быть ещё как бы на родителе. Объясняется довольно просто: в браузере курсор может быть только над одним объектов (либо максимально вложенным, либо на самом верхнем по z-индексу).

Обратите внимание на важную деталь.

Событие `mouseover`, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

**События mouseenter и mouseleave**

События `mouseenter/mouseleave` похожи на `mouseover/mouseout`. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.

Но есть и пара важных отличий:

1.  Переходы внутри элемента, на его потомки и с них, не считаются.
2.  События `mouseenter/mouseleave` не всплывают.

События `mouseenter/mouseleave` предельно просты и понятны.

Когда указатель появляется над элементом – генерируется `mouseenter`, причём не имеет значения, где именно указатель: на самом элементе или на его потомке.

Событие `mouseleave` происходит, когда курсор покидает элемент.

**Немного про делегирование**

События `mouseenter/leave` просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

Что ж, не проблема – будем использовать `mouseover/mouseout`.