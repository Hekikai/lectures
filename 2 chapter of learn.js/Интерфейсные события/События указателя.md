Для обработки событий от мыши, стилуса, пера, касаний по сенсорному экрану был внедрен стандарт "Pointer Events". Он предоставляет единый набор событий для всех типов указывающих устройств.

Если вы не разрабатываете под старые браузеры, такие как Internet Explorer 10, Safari 12, или более ранние версии, больше нет необходимости использовать события мыши или касаний – можно переходить сразу на события указателя.

При этом ваш код будет корректно работать и с сенсорными устройствами и с мышью. Впрочем, у событий указателя есть важные особенности, которые нужно знать, чтобы их правильно использовать, без лишних сюрпризов. Мы отметим их в этой статье.

**Типы событий указателя**

Схема именований событий указателя похожа на события мыши:
![[Pasted image 20220203153951.png]]

Как мы видим, для каждого `mouse<события>` есть соответствующее `pointer<событие>`, которое играет аналогичную роль. Также есть 3 дополнительных события указателя, у которых нет соответствующего аналога `mouse...`, скоро мы их разберём.

**Свойства событий указателя**

События указателя содержат те же свойства, что и события мыши, например `clientX/Y`, `target` и т.п., и несколько дополнительных:

-   `pointerId` – уникальный идентификатор указателя, вызвавшего событие.
    
    Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач (увидим примеры ниже).
    
-   `pointerType` – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch».
    
    Мы можем использовать это свойство, чтобы определять разное поведение для разных типов указателей.
    
-   `isPrimary` – равно `true` для основного указателя (первый палец в мульти-тач).
    

Некоторые устройства измеряют область контакта и степень надавливания, например пальца на сенсорном экране, для этого есть дополнительные свойства:

-   `width` – ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно `1`.
-   `height` – высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно `1`.
-   `pressure` – степень давления указателя в диапазоне от 0 до 1. Для устройств, которые не поддерживают давление, принимает значение `0.5` (нажато) либо `0`.
-   `tangentialPressure` – нормализованное тангенциальное давление.
-   `tiltX`, `tiltY`, `twist` – специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности.

Эти свойства большинством устройств не поддерживаются, поэтому редко используются. При необходимости, подробности о них можно найти в [спецификации](https://w3c.github.io/pointerevents/#pointerevent-interface).

**Мульти-тач**

Одной из функций, которую абсолютно не поддерживают события мыши, является мульти-тач: возможность касаться сразу нескольких мест на телефоне или планшете или выполнять специальные жесты.

События указателя позволяют обрабатывать мульти-тач с помощью свойств `pointerId` и `isPrimary`.

Вот что происходит, когда пользователь касается сенсорного экрана в одном месте, а затем в другом:

1.  При касании первым пальцем:
    -   происходит событие `pointerdown` со свойством `isPrimary=true` и некоторым `pointerId`.
2.  При касании вторым и последующими пальцами (при остающемся первом):
    -   происходит событие `pointerdown` со свойством `isPrimary=false` и уникальным `pointerId` для каждого касания.

Обратите внимание: `pointerId` присваивается не на всё устройство, а для каждого касающегося пальца. Если коснуться экрана 5 пальцами одновременно, получим 5 событий `pointerdown`, каждое со своими координатами и индивидуальным `pointerId`.

События, связанные с первым пальцем, всегда содержат свойство `isPrimary=true`.

Мы можем отслеживать несколько касающихся экрана пальцев, используя их `pointerId`. Когда пользователь перемещает, а затем убирает палец, получаем события `pointermove` и `pointerup` с тем же `pointerId`, что и при событии `pointerdown`.

**Событие - pointer.cancel**

Событие `pointercancel` происходит, когда текущее действие с указателем по какой-то причине прерывается, и события указателя больше не генерируются.

К таким причинам можно отнести:

-   Указывающее устройство было физически выключено.
-   Изменилась ориентация устройства (перевернули планшет).
-   Браузер решил сам обработать действие, считая его жестом мыши, масштабированием и т.п.

Мы продемонстрируем `pointercancel` на практическом примере, чтобы увидеть, как это влияет на нас.

Допустим, мы реализуем перетаскивание («drag-and-drop») для нашего мяча.

Вот последовательность действий пользователя и соответствующие события:

1.  Пользователь нажимает на изображении, чтобы начать перетаскивание
    -   происходит событие `pointerdown`
2.  Затем он перемещает указатель, двигая изображение
    -   происходит событие `pointermove` (возможно, несколько раз)
3.  И тут происходит сюрприз! Браузер имеет встроенную поддержку «Drag’n’Drop» для изображений, которая запускает и перехватывает процесс перетаскивания, генерируя при этом событие `pointercancel`.
    -   Теперь браузер сам обрабатывает перетаскивание изображения. У пользователя есть возможность перетащить изображение мяча даже за пределы браузера, в свою почтовую программу или файловый менеджер.
    -   Событий `pointermove` для нас больше не генерируется.

Таким образом, браузер «перехватывает» действие: в начале переноса drag-and-drop запускается событие `pointercancel`, и после этого события `pointermove` больше не генерируются.

Мы бы хотели реализовать перетаскивание самостоятельно, поэтому давайте скажем браузеру не перехватывать его.

**Предотвращайте действие браузера по умолчанию, чтобы избежать `pointercancel`.**

Нужно сделать две вещи:

1.  Предотвратить запуск встроенного drag’n’drop
    -   Мы можем сделать это, задав `ball.ondragstart = () => false`, как описано в статье [[Drag'n'Drop]].
    -   Это работает для событий мыши.
2.  Для устройств с сенсорным экраном существуют другие действия браузера, связанные с касаниями, кроме drag’n’drop. Чтобы с ними не возникало проблем:
    -   Мы можем предотвратить их, добавив в CSS свойство `#ball { touch-action: none }`.
    -   Затем наш код начнёт корректно работать на устройствах с сенсорным экраном

После того, как мы это сделаем, события будут работать как и ожидается, браузер не будет перехватывать процесс и не будет вызывать событие `pointercancel`.