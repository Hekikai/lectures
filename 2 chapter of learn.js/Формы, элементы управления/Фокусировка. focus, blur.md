Фокусировка и блюр - важные особенности работы форм с пользователем. Фокусировка очень часто означает "введите данные" или "обратите внимание вот на это", а блюр - то есть потеря фокусировки - означает, зачастую, что данные отправлены, или же данные проверяются.

"Ходить" по элементам можно с помощью клавиши Tab, которая тоже работает с фокусировкой, описанной выше.

**События focus/blur**

Событие `focus` вызывается в момент фокусировки, а `blur` – когда элемент теряет фокус. Они используются для валидации (проверки) введенных данных.

В примере ниже:

-   Обработчик `blur` проверяет, введён ли email, и если нет – показывает ошибку.
-   Обработчик `focus` скрывает это сообщение об ошибке (в момент потери фокуса проверка повторится):

```html
Ваш email: <input type="email" id="input">
	<div id="error"></div>

<script>
input.onblur = function() {
	if(!input.value.includes("@")) {
		input.classList.add('invalid');
		error.innerHTML = 'Пожалуйста, введите правильный email.'
	}
};

input.onfocus = function() {
	if(this.classList.contains('invalid')) {
		this.classList.remove('invalid');
		error.innerHTML = "";
	}
};
</script>
```

Современный HTML позволяет делать валидацию с помощью атрибутов `required`, `pattern` и т.д. Иногда – это всё, что нам нужно. JavaScript можно использовать, когда мы хотим больше гибкости. А ещё мы могли бы отправлять изменённое значение на сервер, если оно правильное.

**Методы focus/blur**

Методы `elem.focus()` и `elem.blur()` устанавливают и снимают фокус соотвественно.
С помощью этих методов можно как бы "запретить" пользователю перемещаться на другие элементы! Просто добавив в конец функции `onblur` метод `focus()` на нужный элемент.

Отметим, что мы не можем «отменить потерю фокуса», вызвав `event.preventDefault()` в обработчике `onblur` потому, что `onblur` срабатывает _после_ потери фокуса элементом.

Потеря фокуса случается довольно часто: пользователь кликает в другое место, а также модальное окно (`alert`) уводит фокус на себя, но когда оно закрывается, то возвращает фокус на место.
Если удалить элемент из DOM, то фокус будет также потерян. Если элемент вернуть обратно, то фокус не вернётся.

**Включаем фокусировку на любом элементе: tabindex**

Не на всех элементах есть фокусировка по дефолту. Но она точно всегда есть на `button`, `input`, `select`, `a` и т.д.

С другой стороны, элементы форматирования `<div>`, `<span>`, `<table>` – по умолчанию не могут получить фокус. Метод `elem.focus()` не работает для них, и события `focus/blur` никогда не срабатывают.

И это можно исправить с помощью атрибута `tabindex`. Любой элемент поддерживает фокусировку, если имеет `tabindex`. 

Порядок перебора таков: идут все элементы сначала с `tabindex=1` и по возрастанию, далее идут элементы без `tabindex`; если элементы имеют одинаковый `tabindex`, то они идут в том порядке, в котором они лежат в документе.

Есть два спец.значения:
- `tabindex="0"` ставит элемент в один ряд с элементами без `tabindex`. То есть, при переключении такие элементы будут после элементов с `tabindex ≥ 1`.
Обычно используется, чтобы включить фокусировку на элементе, но не менять порядок переключения. Чтобы элемент мог участвовать в форме наравне с обычными `<input>`.

- `tabindex="-1"` позволяет фокусироваться на элементе только программно. Клавиша Tab проигнорирует такой элемент, но метод `elem.focus()` будет действовать.

Свойство `elem.tabIndex` можно добавить из JavaScript.

**События focusin/focusout**

События `focus` и `blur` не всплывают. Поэтому, если даже и назначить форме это события (`onfocus`, `onblur`) в атрибуте (или через Js, неважно), то, нажав на элемент в форме, ничего не будет работать.

Потому что события срабатывает только на элементе!, а не на всей форме.

У этой проблемы два решения.

Первое: забавная особенность – `focus/blur` не всплывают, но передаются вниз на фазе перехвата. То есть их можно назначить через `addEventListener`.

Второе решение: события `focusin` и `focusout` – такие же, как и `focus/blur`, но они всплывают.

Заметьте, что эти события должны использоваться с `elem.addEventListener`, но не с `on<event>`.